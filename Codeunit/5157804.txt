OBJECT Codeunit 5157804 CSV Port Procedures
{
  OBJECT-PROPERTIES
  {
    Date=18.08.14;
    Time=10:16:57;
    Modified=Yes;
    Version List=OPP7.02.01,6.0,HME1299;
  }
  PROPERTIES
  {
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      GLSetup@5157817 : Record 98;
      OPplusSetup@5157803 : Record 5157802;
      PmtImportInterface@5157819 : Record 5157810;
      PmtImportLine@5157822 : Record 5157809;
      ImportJournal@5157831 : Record 5157808;
      Port@1140009 : Record 5157805;
      PortLine@1140008 : Record 5157806;
      PortLineMapping@1000000000 : Record 5157818;
      All@1140007 : Record 2000000041;
      Objects@5157804 : Record 2000000001;
      CompanyTemp@5157805 : TEMPORARY Record 2000000006;
      NoSeriesMgmt@5157806 : Codeunit 396;
      CommonDlgMgt@5157815 : Codeunit 412;
      FileMgt@5157835 : Codeunit 419;
      FinanceTools@5157802 : Codeunit 5157802;
      myRec@1140003 : RecordRef;
      ImportRegisterNo@5157821 : Code[20];
      ImportFileName@5157833 : Text[255];
      MessageFilename@5157841 : Text[255];
      ServerFileName@5157840 : Text[1024];
      TableCaption@5157844 : Text[50];
      Delimiter@1140002 : Text[1];
      Separator@5157842 : Text[1];
      Counter@1140000 : Integer;
      Text001@1140011 : TextConst 'DEU=Datei %1 nicht gefunden.;ENU=File %1 not found.';
      Text002@1140010 : TextConst 'DEU=Keine Felder definiert oder alle unterdrÅckt.;ENU=No Fields defined or all Fields marked ''Processing only''.';
      Text003@5157854 : TextConst 'DEU=OPplus-CSV-Port (*.oppc)|*.oppc|CSV-Dateien (*.csv)|*.csv|Alle Dateien (*.*)|*.*;ENU=OPplus CSV Port (*.oppc)|*.oppc|CSV Files (*.csv)|*.csv|All Files (*.*)|*.*';
      Text004@1140031 : TextConst 'DEU=FÅr den Bankimport muss Feld %1 definiert und aktiv sein.;ENU=Field %1 has to be defined and active for importing pmt. entry files.';
      Text005@1140012 : TextConst 'DEU=Alle bestehenden Datenspalten werden gelîscht.\Trotzdem fortfahren?;ENU=Existing Lines will be deleted.\Continue anyway?';
      TAB@1140013 : Text[1];
      COLON@5157818 : Text[1];
      myType@1140020 : 'Integer,Decimal,Date';
      CRLF@1140014 : Text[2];
      AccountsInserted@5157810 : Integer;
      "Records Inserted"@1140022 : Integer;
      "Records Modified"@1140023 : Integer;
      "Records Skipped"@5157811 : Integer;
      PmtEntryTableID@5157807 : Integer;
      PrimaryKeyField@1140030 : Integer;
      PrimaryKeyInt@1140028 : Integer;
      StmtLineNo@5157857 : Integer;
      PrimaryKeyCode@1140029 : Code[20];
      Text006@5157808 : TextConst 'DEU=Zeile %1: Keine Angaben zum Konto.;ENU=Line %1: Account could not be identified.';
      Text007@5157809 : TextConst 'DEU=Es sind nicht alle SchlÅsselfelder vorhanden.;ENU="All Fields in the Key must be defined. "';
      Text008@5157812 : TextConst 'DEU=Wollen Sie %1 auf die Standardwerte zurÅcksetzen?;ENU=%1 already exists. Reset to defaults?';
      Text009@5157813 : TextConst 'DEU=Schnittstelle nach %1-Muster;ENU=Interface conforming to %1';
      Text010@5157814 : TextConst 'DEU=%1 Standardschnittstelle(n) definiert, %2 angelegt, %3 zurÅckgesetzt.;ENU=%1 Standard Interface(s) defined,\%2 created,\%3 set to defaults.';
      Text011@5157855 : TextConst 'DEU=Kontoauszug / Avis îffnen;ENU=Open Bank Account Statement / Payment Memo';
      Text012@5157816 : TextConst 'DEU=%1 %2 angelegt.;ENU=%1 %2 inserted.';
      Text013@5157823 : TextConst 'DEU=%1 CSV-Port-Beschreibungen exportiert nach %2.;ENU=%1 CSV Port descriptions exported to %2.';
      Text014@5157824 : TextConst 'DEU="%1 CSV-Port-Beschreibungen in Importdatei gefunden; %2 eingetragen, %3 Åbersprungen.";ENU="%1 CSV Port descriptions found in import file; %2 inserted, %3 skipped."';
      Text015@5157826 : TextConst 'DEU=CSV-Port-Beschreibung(en) speichern unter.;ENU=Save CSV Port description(s).';
      Text016@5157827 : TextConst 'DEU=CSV-Port-Beschreibung(en) îffnen.;ENU=Open CSV Port description(s).';
      Text017@5157828 : TextConst 'DEU=Textdateien (*.txt)|*.txt|CSV-Dateien (*.csv)|*.csv|Alle Dateien (*.*)|*.*;ENU=Text Files (*.txt)|*.txt|CSV Files (*.csv)|*.csv|All Files (*.*)|*.*';
      Text018@5157829 : TextConst 'DEU=Wollen Sie die Datei %1 lîschen?;ENU=Do you want to delete file %1?';
      Text019@5157830 : TextConst 'DEU="<Platzhalter: ";ENU="<Dummy: "';
      Text020@5157834 : TextConst 'DEU=CSV/Text-Datei îffnen;ENU=Open CSV/Text File';
      DecimalSeparator@5157836 : Text[1];
      ThousandSeparator@5157837 : Text[1];
      Text023@5157839 : TextConst 'DEU=Datei %1 konnte nicht auf den Server hochgeladen werden.;ENU=File %1 could not be uploaded to server.';
      Text024@5157843 : TextConst 'DEU=Tabelle %1 existiert in dieser Datenbank nicht (mehr).;ENU=Table %1 (no longer) exists in this database.';
      Text025@5157825 : TextConst 'DEU=Es sollen mehr SÑtze ausgelassen werden, als in der %1 vorhanden sind.;ENU=You want do drop/skip more records than %1 contains.';
      xmlDoc@5157832 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 3.0:{F6D90F11-9C73-11D3-B32E-00C04F990BB4}:'Microsoft XML, v3.0'.DOMDocument";
      xmlNode1@5157846 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 3.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v3.0'.IXMLDOMNode";
      xmlNode2@5157848 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 3.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v3.0'.IXMLDOMNode";
      xmlTool@5157847 : Codeunit 6224;
      DEBUG@5157845 : Boolean;
      dFile@5157820 : File;
      XML@5157849 : Boolean;
      Preview@5157852 : Boolean;
      PreviewStartRecord@5157838 : Integer;
      PreviewRecord@5157850 : Integer;
      PreviewColumn@5157851 : Integer;
      PreviewMax@5157853 : Integer;
      Text026@5157856 : TextConst 'DEU=Fehler beim ôffnen von %1.;ENU=Could not open %1.';
      autocounter@5157858 : ARRAY [256] OF Integer;
      SearchStr1@5157860 : Text[1];
      SearchStr2@5157859 : Text[1];
      MaxLenOldValue@5157861 : Integer;
      PreCheckNeeded@5157863 : Boolean;
      OPPLicenseInfo@5157862 : Codeunit 5158000;
      Text027@5157864 : TextConst 'DEU=Die Benutzung der CSV Ports ist mit dem Granule 5157930 nicht zugelassen. Bitte wenden Sie sich an Ihren HÑndler.;ENU=The usage of CSV-Ports is not permitted with Granule 5157930. Please contact your dealer.';
      CallLevel@5157865 : Integer;
      InsertNewLine@1000000001 : Boolean;
      BaseFieldNo@1000000003 : Integer;
      ReplacewithFieldNo@1000000002 : Integer;
      myRec2@1000000004 : RecordRef;
      TempValue@1000000005 : Decimal;
      BCCodefornewLine@1000000006 : Code[10];
      "*HME**************************"@1000000007 : Integer;
      ImportInterface@1000000008 : Record 5157810;

    PROCEDURE RunPreview@5157819(PortCode@5157802 : Code[20]);
    BEGIN
      Import(PortCode,'',TRUE);
    END;

    PROCEDURE Import@1140018(PortCode@1140000 : Code[20];Filename@5157814 : Text[1024];PreviewPara@5157808 : Boolean) : Integer;
    VAR
      Pmt@5157815 : Boolean;
      Window@5157817 : Dialog;
      ImportFile@5157804 : File;
      ImportStream@5157805 : InStream;
      FileLen@5157810 : Integer;
      Indicator@5157809 : Integer;
      LinesRead@5157806 : Integer;
      MaxLine@5157807 : Integer;
      Line@5157802 : Text[1024];
      Serverfilename@5157803 : Text[1024];
      BigLine@5157812 : BigText;
      MaxLineLen@5157816 : Integer;
      i@5157811 : Integer;
      n@5157813 : Integer;
      Text10000@5157818 : TextConst 'DEU=Import von: #1#################;ENU=Import of: #1#################';
      Text20000@5157819 : TextConst 'DEU=\Eingelesen: @2@@@@@@@@@@;ENU=\Done: @2@@@@@@@@@@';
      Text30000@5157820 : TextConst 'DEU=Die Datei hat weniger Zeilen, als Åbersprungen werden sollen (%1 | %2).;ENU=The File has less lines than lines to be skipped/dropped (%1 | %2).';
      Big2@5157822 : BigText;
      continue@5157821 : Boolean;
      PortLineTest@5157823 : Record 5157806;
      actCompany@5157824 : Text[30];
    BEGIN
      CLEARALL;
      Preview := PreviewPara;

      // Test CSV Port
      Port.RESET;
      Port.GET(PortCode);
      Pmt := Port.BankImport;
      TestTable;
      IF Filename = '' THEN
        Port.TESTFIELD("File Name");

      //H1299 18.08.14 ARI ++++++++++++++++++++++++++++++++++
      IF Port."Check File for Line Breaks" THEN
        Port."File Name" := CheckforValidLineBreaks(Port."File Name");
      //H1299 18.08.14 ARI ----------------------------------

      //H1097 04.06.2014 ARI ++++++++++++++++++++
      IF Port."Pmt. Import Interface Code" <> '' THEN
        ImportInterface.GET(Port."Pmt. Import Interface Code");
      //H1097 04.06.2014 ARI --------------------

      PortLine.RESET;
      PortLine.SETRANGE(Code,Port.Code);
      PortLine.SETRANGE("Processing Only",FALSE);
      IF NOT PortLine.FIND('-') THEN
        ERROR(Text002);
      PortLine.SETCURRENTKEY(Code,"Table No.",Position);

      // Test File
      IF FinanceTools.fsExists(Filename) THEN
        ImportFileName := Filename
      ELSE IF FinanceTools.fsExists(Port."File Name") THEN
        ImportFileName := Port."File Name"
      ELSE BEGIN
        ImportFileName := GetFileName(Port."File Name",'');
        IF (ImportFileName <> Port."File Name") AND (STRPOS(Port."File Name",'*') = 0) THEN BEGIN
          Port."File Name" := ImportFileName;
          Port.MODIFY;
        END;
      END;

      MessageFilename := SetGlobals(ImportFileName);
      IF NOT FinanceTools.fsExists(ImportFileName) THEN
        ERROR(Text001,MessageFilename);
      IF ISSERVICETIER THEN BEGIN
        Serverfilename := FileMgt.ServerTempFileName('','txt');
        IF NOT FileMgt.SilentUpload(ImportFileName,Serverfilename) THEN
          ERROR(Text023,MessageFilename)
      END ELSE
        Serverfilename := ImportFileName;

      IF NOT OPPLicenseInfo.IsStandard AND NOT OPPLicenseInfo.IsEnterprise THEN
        ERROR(Text027);

      // Detailed Test CSV Port
      myRec.OPEN(Port."Table No.");
      IF Pmt THEN
        CheckPayment()
      ELSE
        CheckKeys();

      ImportFile.WRITEMODE := FALSE;
      IF NOT ImportFile.OPEN(Serverfilename) THEN
        ERROR(Text026,MessageFilename);
      ImportFile.CREATEINSTREAM(ImportStream);
      FileLen := ImportFile.LEN;
      MaxLineLen := MAXSTRLEN(Line);

      // Count lines, get MaxLine
      MaxLine := 0;
      IF Port.SkipLines + Port.DropLines > 0 THEN BEGIN
        REPEAT
          n := ImportStream.READTEXT(Line,MaxLineLen);
          IF n < MaxLineLen THEN
            MaxLine += 1;
        UNTIL ImportStream.EOS;
        MaxLine := MaxLine - (Port.SkipLines + Port.DropLines);
        IF MaxLine < 1 THEN
          ERROR(Text30000,MaxLine,Port.SkipLines + Port.DropLines);
        // Reset Stream
        // existing code confuses lineno. and linecounter, so if next line is omitted
        // skiplines will be counted twice
        MaxLine += Port.SkipLines;
        CLEAR(ImportStream);
        ImportFile.CREATEINSTREAM(ImportStream);
        WHILE LinesRead < Port.SkipLines DO BEGIN
          n := ImportStream.READTEXT(Line,MaxLineLen);
          IF n < MaxLineLen THEN
            LinesRead +=1;
        END;
      END;

      PortLine.RESET;
      PortLine.SETCURRENTKEY(Code,"Table No.",Position);
      PortLine.SETRANGE(Code,Port.Code);

      IF Preview THEN
        PreviewProcedures(1,'');

      CLEAR(myRec);
      myRec.OPEN(Port."Table No.");

      PortLineTest.SETRANGE(Code,Port.Code);
      PortLineTest.SETFILTER("Filter to ignore",'<>%1','');
      IF PortLineTest.FINDFIRST THEN
        PreCheckNeeded := TRUE
      ELSE
        PreCheckNeeded := FALSE;

      //H0581 06.03.2014  ARI ++++++++++++++++++++++++++++++++
      IF GUIALLOWED THEN BEGIN
      //H0581 06.03.2014  ARI --------------------------------
        Indicator := 1;
        Window.OPEN(Text10000 + Text20000, MessageFilename, Indicator);
        CLEAR(autocounter);
      //H0581 06.03.2014  ARI ++++++++++++++++++++++++++++++++
      END;
      //H0581 06.03.2014  ARI --------------------------------

      // FixCol
      IF Port.LineLen > 0 THEN BEGIN
        MaxLineLen := Port.LineLen;
        REPEAT
          continue := TRUE;
          //H0581 06.03.2014  ARI ++++++++++++++++++++++++++++++++
          IF GUIALLOWED THEN
          //H0581 06.03.2014  ARI --------------------------------
            IF (LinesRead MOD 20 = 0) THEN BEGIN
              Indicator := ROUND(ImportFile.POS/FileLen*10000,1);
              Window.UPDATE(2,Indicator);
            END;
          n := ImportStream.READTEXT(Line,MaxLineLen);
          LinesRead += 1;
          BigLine.ADDTEXT(Line);
          IF Port.FilterStr <> '' THEN
            IF Port."Filter As Exclude" THEN
              IF STRPOS(Line,Port.FilterStr) = 0 THEN
                continue := TRUE
              ELSE
                continue := FALSE
            ELSE
              IF STRPOS(Line,Port.FilterStr) = 0 THEN
                continue := FALSE
              ELSE
                continue := TRUE;
          IF continue THEN
            IF PreCheckNeeded THEN
              IF PreCheckFilter(BigLine) THEN
                ProcessImportLine(BigLine,Big2)
            ELSE
              ProcessImportLine(BigLine,Big2);
          CLEAR(BigLine);
          CLEAR(Big2);
        UNTIL n < MaxLineLen;
      END ELSE BEGIN
        // CSV
        WHILE NOT ImportStream.EOS DO BEGIN
      //H0993 23.04.14 ARI +++++++++++++++++++++++++++++++++++++
        InsertNewLine := FALSE;
      //H0993 23.04.14 ARI -------------------------------------

          continue := TRUE;
          //H0581 06.03.2014  ARI ++++++++++++++++++++++++++++++++
          IF GUIALLOWED THEN
          //H0581 06.03.2014  ARI --------------------------------
            IF (LinesRead MOD 20 = 0) THEN BEGIN
              Indicator := ROUND(ImportFile.POS/FileLen*10000,1);
              Window.UPDATE(2,Indicator);
            END;
          n := ImportStream.READTEXT(Line,MaxLineLen);
          BigLine.ADDTEXT(Line);
          IF n < MaxLineLen THEN BEGIN
            IF Port.FilterStr <> '' THEN
              IF Port."Filter As Exclude" THEN
                IF STRPOS(Line,Port.FilterStr) = 0 THEN
                  continue := TRUE
                ELSE
                  continue := FALSE
              ELSE
                IF STRPOS(Line,Port.FilterStr) = 0 THEN
                  continue := FALSE
                ELSE
                  continue := TRUE;
            LinesRead += 1;
            IF continue THEN
              IF BigLine.LENGTH > 0 THEN BEGIN
                IF MaxLine = 0 THEN BEGIN
                  IF PreCheckNeeded THEN BEGIN
                    IF PreCheckFilter(BigLine) THEN
                      ProcessImportLine(BigLine,Big2);
                  END ELSE
                    ProcessImportLine(BigLine,Big2);
                END ELSE IF LinesRead <= MaxLine THEN BEGIN
                  IF PreCheckNeeded THEN BEGIN
                    IF PreCheckFilter(BigLine) THEN
                      ProcessImportLine(BigLine,Big2);
                  END ELSE
                    ProcessImportLine(BigLine,Big2);
                END;
              END;
            CLEAR(BigLine);
            CLEAR(Big2);
          END;
        END;
      END;

      ImportFile.CLOSE;
      //H0581 06.03.2014  ARI ++++++++++++++++++++++++++++++++
      IF GUIALLOWED THEN
      //H0581 06.03.2014  ARI --------------------------------
        Window.CLOSE;
      myRec.CLOSE;
      CLEAR(ImportStream);
      CLEAR(ImportFile);
      CLEAR(myRec);

      IF Preview THEN BEGIN
        COMMIT;
        PreviewProcedures(4,'')
      END ELSE BEGIN
        IF Pmt THEN BEGIN
          IF NOT CompanyTemp.FIND('-') THEN BEGIN
            CompanyTemp.Name := COMPANYNAME;
            CompanyTemp.INSERT;
          END;
          IF CompanyTemp.FINDSET(FALSE,FALSE) THEN BEGIN
            actCompany := COMPANYNAME;
            REPEAT
              ImportJournal.CHANGECOMPANY(CompanyTemp.Name);
                ImportJournal.SETRANGE("In Progress",TRUE);
                IF ImportJournal.FIND('-') THEN REPEAT
                  ImportJournal.CALCFIELDS("No. of Entries");
                  ImportJournal."Total No. of Entries" := ImportJournal."No. of Entries";
                  ImportJournal."Data from Company" := actCompany;
                  ImportJournal.MODIFY;
                UNTIL ImportJournal.NEXT = 0;
              ImportJournal.MODIFYALL("In Progress",FALSE);
            UNTIL CompanyTemp.NEXT = 0;
          END;
          IF (AccountsInserted > 0) THEN
            MESSAGE(Text012, AccountsInserted,PmtImportInterface.TABLECAPTION);
        END ELSE BEGIN
          IF Port.Logfile THEN
            LogFile(MessageFilename);
        END;

        IF Port."Delete Import File" = Port."Delete Import File"::Ask THEN BEGIN
          IF CONFIRM(Text018,TRUE,MessageFilename) THEN
            FinanceTools.fsErase(ImportFileName);
        END ELSE IF Port."Delete Import File" = Port."Delete Import File"::Yes THEN
          FinanceTools.fsErase(ImportFileName)
        ELSE IF Port."Delete Import File" = Port."Delete Import File"::Backup THEN BEGIN
          IF Port.BankImport THEN
            FinanceTools.fsRename(ImportFileName,OPplusSetup."MT940 Backup Path" + MessageFilename);
        END;

      END;

      IF DEBUG THEN
        dFile.CLOSE;

      EXIT(AccountsInserted);
    END;

    PROCEDURE ProcessImportLine@1140003(VAR BigLine@1140000 : BigText;VAR BigLine2@5157807 : BigText) : Boolean;
    VAR
      TempText@1140002 : Text[1024];
      Pos@1140001 : Integer;
      myField@1140003 : FieldRef;
      SkipValidate@5157805 : Boolean;
      TempBool@1140004 : Boolean;
      TempInt@1140005 : Integer;
      TempDec@1140007 : Decimal;
      TempTime@1140008 : Time;
      TempDateTime@1140009 : DateTime;
      TempCode@1140010 : Code[30];
      HasDelimiter@1140015 : Boolean;
      TempOptionStr@5157802 : Text[255];
      k@5157803 : Integer;
      OptionDone@5157804 : Boolean;
      Negative@5157806 : Boolean;
      TestStr@5157809 : Text[30];
      cutStr@5157811 : Text[30];
      MapStr@5157812 : Text[30];
      MapStr2@5157815 : Text[30];
      pos_1@5157813 : Integer;
      LastLineNo@5157814 : Integer;
      Temptext2@5157810 : Text[1024];
      z1@5157816 : Integer;
      z2@5157817 : Integer;
      Row@5157818 : Text[30];
      Operand@5157819 : Text[255];
      Operator@5157820 : Text[1];
      NextSign@5157821 : Text[1];
      NextSignString@5157822 : Text[255];
      NextSignPos@5157823 : Integer;
      Operators@5157824 : Text[8];
      CalcDeci@5157826 : Decimal;
      Rowlength@5157825 : Integer;
      PortLineMapping_Temp@5157808 : TEMPORARY Record 5157818;
      CalcDec@5157827 : Decimal;
      TextTemp@5157828 : Text[255];
      myField2@1000000000 : FieldRef;
      myField3@1000000001 : FieldRef;
    BEGIN
      IF Preview THEN BEGIN
        PreviewRecord += 1;
        PreviewProcedures(2,'');
        PreviewColumn := 0;
      END;

      myRec.INIT;
      IF NOT Port.BankImport THEN BEGIN
        IF PrimaryKeyField > 0 THEN BEGIN
          myField :=  myRec.FIELD(PrimaryKeyField);
          IF PrimaryKeyInt > 0 THEN BEGIN;
            myField.VALUE := PrimaryKeyInt;
            PrimaryKeyInt += 1;
          END ELSE IF PrimaryKeyCode <> '' THEN BEGIN
            myField.VALUE := PrimaryKeyCode;
            PrimaryKeyCode := INCSTR(PrimaryKeyCode);
          END;
        END;
      END;

      PortLine.FIND('-');
      PortLineMapping.RESET;
      PortLineMapping.SETCURRENTKEY("CSV Port Code","CSV Port Line No.","Old Value");
      MaxLenOldValue := MAXSTRLEN(PortLineMapping."Old Value");

      REPEAT
        CLEAR(TempText);
        // Extract FieldText

      //H0993 23.04.14 ARI ++++++++++++++++++++++++++++++++++++++++
        IF PortLine."Insert new Line" THEN BEGIN
          InsertNewLine := TRUE;
          BaseFieldNo := PortLine."Field No.";
          ReplacewithFieldNo := PortLine."Replace with FieldNo";
          BCCodefornewLine := PortLine."BC Code for new Line";
        END;
      //H0993 23.04.14 ARI ----------------------------------------

        IF Port.FixCol THEN BEGIN
          IF PortLine.Colwidth > 0 THEN
            BigLine.GETSUBTEXT(TempText,PortLine.StartPos,PortLine.Colwidth);
        END ELSE BEGIN
          Pos := BigLine.TEXTPOS(Separator);
          IF Pos < 1 THEN BEGIN
            BigLine.GETSUBTEXT(TempText,1);
            IF Delimiter <> '' THEN
              TempText := DELCHR(TempText,'<>',Delimiter)
          END ELSE BEGIN
            BigLine.GETSUBTEXT(TempText,1,1);
            CLEAR(HasDelimiter);
            IF TempText = Delimiter THEN BEGIN
              HasDelimiter := TRUE;
              Pos := BigLine.TEXTPOS(Delimiter + Separator);
              IF Pos > 0 THEN BEGIN
                BigLine.GETSUBTEXT(TempText,2,Pos-2);
                BigLine.GETSUBTEXT(BigLine2,Pos+2);
              END;
            END ELSE BEGIN
              Pos := BigLine.TEXTPOS(Separator);
              IF Pos > 0 THEN BEGIN
                BigLine.GETSUBTEXT(TempText,1,Pos-1);
                BigLine.GETSUBTEXT(BigLine2,Pos+1);
              END;
            END;
          END;
          CLEAR(BigLine);
          BigLine2.GETSUBTEXT(BigLine,1);
          CLEAR(BigLine2);
        END;

        IF Preview THEN
          SkipValidate := TRUE
        ELSE
          SkipValidate := PortLine.SkipTrigger;

        // Preprocess FieldText, except Encoding (done when necessary)
        TempText := DELCHR(TempText,'<>');
        IF TempText <> '' THEN BEGIN
          IF PortLine.LeftDrop > 0 THEN BEGIN
            IF STRLEN(TempText) >= PortLine.LeftDrop THEN
              TempText := COPYSTR(TempText,PortLine.LeftDrop+1);
          END;
          IF PortLine.RightDrop > 0 THEN BEGIN
            IF STRLEN(TempText) >= PortLine.RightDrop THEN
              TempText := COPYSTR(TempText,1,STRLEN(TempText)-PortLine.RightDrop);
          END;
          IF PortLine.ContentLength > 0 THEN BEGIN
            IF STRLEN(TempText) >= PortLine.ContentLength THEN
              TempText := COPYSTR(TempText,PortLine.ContentLength);
          END;
        END;

        IF PortLine.Formatstring <> '' THEN BEGIN
          SearchStr1 := '%';
          SearchStr2 := '#';
          cutStr := '';
          MapStr := '';
          pos_1 := 0;
          IF STRPOS(PortLine.Formatstring,SearchStr1) > 0 THEN BEGIN
            TempText := COPYSTR(STRSUBSTNO(PortLine.Formatstring,
                                   TODAY, // %1
                                   WORKDATE, // %2
                                   CALCDATE('<-CM-1D>',TODAY), // %3
                                   CALCDATE('<CM>',TODAY)), // %4
                                   1,MAXSTRLEN(TempText));
          END ELSE IF (STRPOS(PortLine.Formatstring,SearchStr2) > 0) THEN BEGIN
            cutStr := PortLine.Formatstring;
            IF  NOT PortLine."Formula included" THEN BEGIN
              REPEAT
                MapStr2 := '';
                IF (STRLEN(cutStr) > 0) AND (STRPOS(cutStr,SearchStr2) = 0) THEN
                  MapStr := cutStr
                ELSE
                  MapStr  := COPYSTR(cutStr,1,STRPOS(cutStr,SearchStr2)-1);
                IF (STRLEN(DELCHR(MapStr,'=','0123456789')) = 0) AND (MapStr <> '') THEN
                  EVALUATE(pos_1,MapStr)
                ELSE
                  IF MapStr <> '' THEN BEGIN
                    IF STRPOS(cutStr,SearchStr2) > 1 THEN
                      MapStr2 := DELCHR(COPYSTR(cutStr,1,STRPOS(cutStr,SearchStr2)-1),'=','0123456789')
                    ELSE
                      MapStr2 := DELCHR(COPYSTR(cutStr,1,STRPOS(cutStr,SearchStr2)),'=','0123456789');
                    MapStr := DELCHR(MapStr,'=',MapStr2);
                    IF (STRLEN(DELCHR(MapStr,'=','0123456789')) = 0) AND (MapStr <> '') THEN
                      EVALUATE(pos_1,MapStr);
                  END;
                IF pos_1 > 0 THEN BEGIN
                  PortLineMapping_Temp.SETRANGE("CSV Port Code",PortLine.Code);
                  IF PortLineMapping_Temp.FINDFIRST THEN BEGIN
                    PortLineMapping_Temp.SETRANGE("CSV Port Line No.",pos_1);
                    IF PortLineMapping_Temp.FINDFIRST THEN BEGIN
                      PortLineMapping_Temp.SETFILTER("Old Value",'=%1','');
                      PortLineMapping_Temp.SETFILTER("New Value",'<>%1','');
                      IF PortLineMapping_Temp.FINDFIRST THEN
                        MapStr := PortLineMapping_Temp."New Value";
                    END;
                  END;
                END;
                IF STRPOS(cutStr,SearchStr2) = 0 THEN
                  cutStr := ''
                ELSE
                  cutStr := DELSTR(cutStr,1,STRPOS(cutStr,SearchStr2));
                TempText := TempText + MapStr + MapStr2;
              UNTIL STRLEN(cutStr) = 0;
            END ELSE IF PortLine."Formula included" THEN BEGIN
              CheckFormula(cutStr);
              REPEAT
                z1 := STRPOS(cutStr,SearchStr2);
                z2 := 1025;
                Row := '';
                pos_1 := 0;
                Operand := '';
                Operator := '';
                MapStr2 := '';
                NextSignString := '';
                NextSign := '';
                NextSignPos := 0;
                MapStr := '';
                IF STRPOS(cutStr,'+') > 0 THEN
                  z2 := STRPOS(cutStr,'+');
                IF (STRPOS(cutStr,'-') > 0) AND (STRPOS(cutStr,'-') < z2) THEN
                    z2 := STRPOS(cutStr,'-');
                IF (STRPOS(cutStr,'/') > 0) AND (STRPOS(cutStr,'/') < z2) THEN
                  z2 := STRPOS(cutStr, '/');
                IF (STRPOS(cutStr,'*') > 0) AND (STRPOS(cutStr,'*') < z2) THEN
                  z2 := STRPOS(cutStr,'*');
                IF (STRPOS(cutStr,'^') > 0) AND (STRPOS(cutStr,'^') < z2) THEN
                  z2 := STRPOS(cutStr,'^');
                IF (STRPOS(cutStr,'(') > 0) AND (STRPOS(cutStr,'(') < z2) THEN
                  z2 := STRPOS(cutStr,'(');
                IF (STRPOS(cutStr,')') > 0) AND (STRPOS(cutStr,')') < z2) THEN
                  z2 := STRPOS(cutStr,')');
                IF ((z1 <> 0) AND (z1 < z2)) OR (z2 = 0) THEN BEGIN
                //H0580 05.03.2014 ARI +++++++++++++++++++++++++++++++++++++++++
                {
                  Rowlength := STRLEN(COPYSTR(cutStr,1,z1+1))-STRLEN(DELSTR(cutStr,z2-1,STRLEN(cutStr)));
                }
                  Rowlength := z2 - 1 - z1;
                //H0580 05.03.2014 ARI -----------------------------------------
                  IF Rowlength = 0 THEN Rowlength := 1;
                  Row := COPYSTR(cutStr,z1+1,Rowlength);
                  cutStr := DELSTR(cutStr,1,z1+Rowlength);
                  EVALUATE(pos_1,Row);
                END ELSE BEGIN
                  IF z2 > 1 THEN BEGIN
                    Operand := COPYSTR(cutStr,1,STRLEN(DELSTR(cutStr,z2,STRLEN(cutStr))));
                    Operator := COPYSTR(cutStr,z2,1);
                    MapStr2 := Operand + Operator;
                    cutStr := DELSTR(cutStr,1,STRLEN(MapStr2));
                  END ELSE BEGIN
                    NextSignString := DELCHR(cutStr,'=','0123456789');
                    IF NextSignString <> '' THEN BEGIN
                      NextSign := COPYSTR(NextSignString,1,1);
                      NextSignPos := STRPOS(cutStr,NextSign);
                    END ELSE
                      NextSignPos := STRLEN(cutStr);
                    IF NextSignPos = 0 THEN
                      NextSignPos := 1;
                    Operand := COPYSTR(cutStr,z2+1,STRLEN(DELSTR(cutStr,NextSignPos,STRLEN(cutStr))));
                    IF Operand = SearchStr2 THEN
                      Operand := '';
                    Operator := COPYSTR(cutStr,z2,1);
                    cutStr := DELSTR(cutStr,1,z2);
                    MapStr2 := Operator + Operand;
                  END;
                END;

                IF pos_1 > 0 THEN BEGIN
                  PortLineMapping_Temp.SETRANGE("CSV Port Code",PortLine.Code);
                  IF PortLineMapping_Temp.FINDFIRST THEN BEGIN
                    PortLineMapping_Temp.SETRANGE("CSV Port Line No.",pos_1);
                    IF PortLineMapping_Temp.FINDFIRST THEN BEGIN
                      PortLineMapping_Temp.SETFILTER("Old Value",'=%1','');
                      PortLineMapping_Temp.SETFILTER("New Value",'<>%1','');
                      IF PortLineMapping_Temp.FINDFIRST THEN BEGIN
                        MapStr := PortLineMapping_Temp."New Value";
                        EVALUATE(CalcDec,MapStr);
                        IF CalcDec <> 0 THEN
                          MapStr := FORMAT(setValue(MapStr,PortLine.Code,pos_1));
                      END;
                    END;
                  END;
                END;
                IF z1 < z2 THEN
                  TempText := TempText + MapStr + MapStr2
                ELSE
                  TempText := TempText + MapStr2 + MapStr;
              UNTIL STRLEN(cutStr) = 0;
            END;
          END ELSE
            TempText := PortLine.Formatstring;
          IF PortLine."Formula included" THEN BEGIN
            Temptext2 := '(' + DELCHR(TempText,'=','.') + ')';
            TempText := Calculate(Temptext2,',');
          END;
        END;
        IF PortLine."Text before" <> '' THEN
          TempText := PortLine."Text before" + TempText;
        IF PortLine."Text after" <> '' THEN
          TempText += PortLine."Text after";
        IF PortLine.Colwidth > 0 THEN
          TempText := COPYSTR(TempText,1,PortLine.Colwidth);

        IF PortLine.CustomProcID <> 0 THEN
          TempText := CustomProcedure(PortLine.CustomProcID,TempText);

        IF PortLine."Auto Increment" THEN BEGIN
          autocounter[PortLine.Position] += PortLine."Increment Value";
          TempText := FORMAT(autocounter[PortLine.Position]);
        END;
        IF (TempText <> '') AND
          (PortLine."Processing Only" = FALSE) AND
          (PortLine."Table No." > 0)
        THEN BEGIN
          PortLineMapping.SETRANGE("CSV Port Code",PortLine.Code);
          IF PortLineMapping.FINDFIRST THEN BEGIN
            PortLineMapping.SETRANGE("CSV Port Line No.",PortLine."Line No.");
            IF PortLineMapping.FINDFIRST THEN BEGIN
              PortLineMapping.SETRANGE("Old Value",COPYSTR(TempText,1,MaxLenOldValue));
              PortLineMapping.SETFILTER("New Value",'<>%1','');
              IF PortLineMapping.FINDFIRST THEN
                TempText := PortLineMapping."New Value";
            END;
          END;
          IF PortLine.Fieldlinking THEN BEGIN
            PortLineMapping_Temp.SETRANGE("CSV Port Code",PortLine.Code);
            PortLineMapping_Temp.SETRANGE("CSV Port Line No.",PortLine."Line No.");
            IF PortLineMapping_Temp.FINDLAST THEN
              LastLineNo := PortLineMapping_Temp."Line No.";
            PortLineMapping_Temp."CSV Port Code" := PortLine.Code;
            PortLineMapping_Temp."CSV Port Line No." := PortLine."Line No.";
            PortLineMapping_Temp."Line No." := LastLineNo + 10000;
            //H0580 05.03.2014 ARI +++++++++++++++++++++++++++++++++++++++++
            IF TempText = ',00' THEN
              TempText := '0,00';
            //H0580 05.03.2014 ARI -----------------------------------------
            PortLineMapping_Temp."New Value" := TempText;
            PortLineMapping_Temp.INSERT;
          END;
        END;
        // Process Field
        IF (TempText <> '') AND
          (PortLine."Processing Only" = FALSE) AND
          (PortLine."Table No." > 0) AND (PortLine."Field No." > 0)
        THEN BEGIN

          All.GET(PortLine."Table No.",PortLine."Field No.");
          myField := myRec.FIELD(PortLine."Field No.");

          IF (All.Class=All.Class::Normal) AND (All.Type <> All.Type::BLOB) THEN BEGIN

            IF Port.Encoding = Port.Encoding::ANSI THEN BEGIN
              IF All.Type IN [All.Type::Code, All.Type::Option, All.Type::Text] THEN
                TempText := FinanceTools.Ansi2Ascii(TempText);
            END;
      //      IF All.Type IN [All.Type::Code, All.Type::Decimal, All.Type::Integer] THEN
      //        TempText := CONVERTSTR(TempText,'+','#');
            IF All.Type IN [All.Type::Decimal, All.Type::Integer] THEN BEGIN
              TempText := DELCHR(TempText,'<>','+');
              Negative := (STRPOS(TempText,'-') = 1) OR (STRPOS(TempText,'-') = STRLEN(TempText));
              IF Negative THEN
                TempText := DELCHR(TempText,'<>','-');
            END;

            CASE All.Type OF

              All.Type::Boolean: BEGIN
                IF EVALUATE(TempBool,TempText) THEN BEGIN
                  IF NOT SkipValidate THEN
                    myField.VALIDATE(TempBool)
                  ELSE
                    myField.VALUE := TempBool;
                END ELSE BEGIN
                  TempText := LOWERCASE(DELCHR(TempText));
                  TempBool := TempText IN ['wahr','true','ja','yes','1'];
                  IF TempBool THEN BEGIN
                    IF NOT SkipValidate THEN
                      myField.VALIDATE(TempBool)
                    ELSE
                      myField.VALUE := TempBool;
                  END;
                END;
              END;

              All.Type::Date: BEGIN
              //H0580 28.02.2014 ARI +++++++++++++++++++++++++++++++++++++
              {
                IF NOT SkipValidate THEN
                  myField.VALIDATE(MakeDate(TempText))
                ELSE
                  myField.VALUE := MakeDate(TempText);
              }
                IF PortLine.TwistedDate THEN BEGIN
                  IF NOT SkipValidate THEN
                    myField.VALIDATE(MakeDate2(TempText))
                  ELSE
                    myField.VALUE := MakeDate2(TempText);
                END ELSE BEGIN
                  IF NOT SkipValidate THEN
                    myField.VALIDATE(MakeDate(TempText))
                  ELSE
                    myField.VALUE := MakeDate(TempText);
                END;
              //H0580 28.02.2014 ARI -------------------------------------
              END;

              All.Type::DateTime: BEGIN
                EVALUATE(TempDateTime,TempText);
                IF NOT SkipValidate THEN
                  myField.VALIDATE(TempDateTime)
                ELSE
                  myField.VALUE := TempDateTime;
              END;

              All.Type::Decimal: BEGIN
                TempText := COPYSTR(TempText,1,All.Len);
                IF TempText <> '' THEN BEGIN
                  IF Port.ThousandSep <> ThousandSeparator THEN
                    TempText := CONVERTSTR(TempText,Port.ThousandSep,'@');
                  IF Port.DecimalSep <> DecimalSeparator THEN
                    TempText := CONVERTSTR(TempText,Port.DecimalSep,DecimalSeparator);
                  TempText := CONVERTSTR(TempText,'@',ThousandSeparator);
                  EVALUATE(TempDec,TempText);
                  IF Negative THEN
                    TempDec := TempDec * -1;
                  IF PortLine.Amounts = PortLine.Amounts::Absolute THEN BEGIN
                    IF TempDec < 0 THEN
                      TempDec := TempDec * -1;
                  END ELSE IF PortLine.Amounts = PortLine.Amounts::Invert THEN
                    TempDec := TempDec * -1
                  ELSE IF PortLine.Amounts = PortLine.Amounts::Default THEN BEGIN
                    IF Port.Amounts = Port.Amounts::Absolute THEN BEGIN
                      IF TempDec < 0 THEN
                        TempDec := TempDec * -1;
                    END ELSE IF Port.Amounts = Port.Amounts::Invert THEN
                      TempDec := TempDec * -1;
                  END;
                  IF PortLine.Factor <> 0 THEN
                    TempDec := TempDec * PortLine.Factor;
                END ELSE
                  TempDec := 0;
                //H1097 26.05.2014 ARI ++++++++++++++++++++++++++
                IF Port.BankImport THEN BEGIN
                  IF PortLine."Deb/Cred Indicator Field No." <> 0 THEN BEGIN
                    myField3 := myRec.FIELD(PortLine."Deb/Cred Indicator Field No.");
                    IF FORMAT(myField3) = ImportInterface."Debit/Credit Indicator" THEN
                      TempDec := TempDec * -1
                  END;
                END;
                //H1097 26.05.2014 ARI --------------------------
                IF NOT SkipValidate THEN
                  myField.VALIDATE(TempDec)
                ELSE
                  myField.VALUE := TempDec;
              END;

              All.Type::Code: BEGIN
                TempText := COPYSTR(TempText,1,All.Len);
                IF EVALUATE(TempCode,TempText) THEN BEGIN
                  IF NOT SkipValidate THEN
                    myField.VALIDATE(TempCode)
                  ELSE
                    myField.VALUE := TempCode;
                END;
              END;

              All.Type::Integer: BEGIN
                EVALUATE(TempInt,TempText);
                IF Negative THEN
                  TempDec := TempDec * -1;
                IF PortLine.Amounts = PortLine.Amounts::Absolute THEN BEGIN
                  IF TempInt < 0 THEN
                    TempInt := TempInt * -1;
                END ELSE IF PortLine.Amounts = PortLine.Amounts::Invert THEN
                  TempInt := TempInt * -1
                ELSE IF PortLine.Amounts = PortLine.Amounts::Default THEN BEGIN
                  IF Port.Amounts = Port.Amounts::Absolute THEN BEGIN
                    IF TempInt < 0 THEN
                      TempInt := TempInt * -1;
                  END ELSE IF Port.Amounts = Port.Amounts::Invert THEN
                    TempInt := TempInt * -1;
                END;
                IF NOT SkipValidate THEN
                  myField.VALIDATE(TempInt)
                ELSE
                  myField.VALUE := TempInt;
              END;

              All.Type::Option: BEGIN
                IF EVALUATE(TempInt,TempText) THEN BEGIN
                  IF NOT SkipValidate THEN
                    myField.VALIDATE(TempInt)
                  ELSE
                    myField.VALUE := TempInt;
                END ELSE BEGIN
                  OptionDone := FALSE;
                  TempText := DELCHR(LOWERCASE(TempText),'<>');
                  TempOptionStr := LOWERCASE(myField.OPTIONSTRING);
                  IF STRPOS(TempOptionStr,TempText) > 0 THEN BEGIN
                    FOR k := 0 TO GetOption(TempOptionStr) DO BEGIN
                      IF COPYSTR(SELECTSTR(k+1,TempOptionStr),1,STRLEN(TempText)) = TempText THEN BEGIN
                        IF NOT SkipValidate THEN
                          myField.VALIDATE(k)
                        ELSE
                          myField.VALUE := k;
                        OptionDone := TRUE;
                      END;
                    END;
                  END;
                  IF NOT OptionDone THEN BEGIN
                    TempOptionStr := LOWERCASE(myField.OPTIONCAPTION);
                    IF STRPOS(TempOptionStr,TempText) > 0 THEN BEGIN
                      FOR k := 0 TO GetOption(TempOptionStr) DO BEGIN
                        IF COPYSTR(SELECTSTR(k+1,TempOptionStr),1,STRLEN(TempText)) = TempText THEN BEGIN
                          IF NOT SkipValidate THEN
                            myField.VALIDATE(k)
                          ELSE
                            myField.VALUE := k;
                          OptionDone := TRUE;
                        END;
                      END;
                    END;
                  END;
                  IF NOT OptionDone THEN BEGIN
                    IF NOT SkipValidate THEN
                      myField.VALIDATE(0)
                    ELSE
                      myField.VALUE := 0;
                  END;
                END;
              END;

              All.Type::Text: BEGIN
                TempText := COPYSTR(TempText,1,All.Len);
                IF PortLine.TextCase = PortLine.TextCase::Lower THEN
                  TempText := LOWERCASE(TempText)
                ELSE IF PortLine.TextCase = PortLine.TextCase::Upper THEN
                  TempText := UPPERCASE(TempText)
                ELSE IF PortLine.TextCase = PortLine.TextCase::Default THEN BEGIN
                  IF Port.TextCase = Port.TextCase::lower THEN
                    TempText := LOWERCASE(TempText)
                  ELSE IF Port.TextCase = Port.TextCase::upper THEN
                    TempText := UPPERCASE(TempText);
                END;

                IF NOT SkipValidate THEN
                  myField.VALIDATE(TempText)
                ELSE
                  myField.VALUE := TempText;
              END;
              All.Type::Time: BEGIN
                EVALUATE(TempTime,TempText);
                IF NOT SkipValidate THEN
                  myField.VALIDATE(TempTime)
                ELSE
                  myField.VALUE := TempTime;
              END;
            END; // case
          END; // Fieldclass Normal, Fieldtype <> BLOB
        END; // empty, process, field defined

        IF Preview THEN BEGIN
          IF (PreviewColumn < PreviewMax + 1) AND
             (PortLine."Field No." <> 0) AND
             (PortLine."Processing Only" = FALSE) AND
             (PortLine.Formatstring = '')
          THEN BEGIN
            PreviewColumn += 1;
            PreviewProcedures(3,TempText);
          END;
        END;
      UNTIL PortLine.NEXT = 0;

      IF NOT Preview THEN BEGIN
        IF Port.BankImport THEN BEGIN
          InsertPmtImportLine(myRec);
      //H0993 23.04.14 ARI ++++++++++++++++++++++++++++++++++++++++
          IF InsertNewLine THEN BEGIN

            myRec2.OPEN(Port."Table No.");
            myRec2 := myRec;

            //Set new BC Code for this Line
            myField2 := myRec2.FIELD(42);
            IF NOT SkipValidate THEN
              myField2.VALIDATE(BCCodefornewLine)
            ELSE
              myField2.VALUE := BCCodefornewLine;

            //Replace Values according to Line Setup
            myField2 := myRec2.FIELD(BaseFieldNo);
            TempValue := myField2.VALUE;

            CASE FORMAT(myField2.TYPE) OF
              'Text' : myField2.VALUE := '';
              'Code' : myField2.VALUE := '';
              'Time' : myField2.VALUE := 0T;
              'Date' : myField2.VALUE := 0D;
              'DateTime' : myField2.VALUE := 0DT;
              'Boolean' : myField2.VALUE := FALSE;
              'Decimal' : myField2.VALUE := 0;
              'Integer' : myField2.VALUE := 0;
            END;

            myField2 := myRec2.FIELD(ReplacewithFieldNo);
            IF NOT SkipValidate THEN
              myField2.VALIDATE(TempValue)
            ELSE
              myField2.VALUE := TempValue;

            //Insert new Record for Fees
            InsertPmtImportLine(myRec2);

            myRec2.CLOSE;
          END;
      //H0993 23.04.14 ARI ----------------------------------------

        END ELSE BEGIN
          IF myRec.INSERT(Port.Trigger) THEN
            "Records Inserted" += 1
          ELSE BEGIN
            IF Port.OnFoundSkip THEN
              "Records Skipped" += 1
            ELSE IF myRec.MODIFY(Port.Trigger) THEN
              "Records Modified" += 1;
          END;
        END;
      END;
      EXIT(TRUE);
    END;

    PROCEDURE Export@1140013(PortCode@1140000 : Code[20]);
    VAR
      myField@1140001 : FieldRef;
      Window@5157811 : Dialog;
      exFile@5157803 : File;
      oStream@5157804 : OutStream;
      BigLine@5157805 : BigText;
      MaxRec@5157809 : Integer;
      MaxField@5157806 : Integer;
      Exported@1140003 : Integer;
      Text10000@5157807 : TextConst 'DEU=#1################# (Exporttabelle)\;ENU=Export of #1################# to #2#################\@3@@@@@@@@@@ records done.';
      Text20000@5157808 : TextConst 'DEU=#2################# (Ausgabedatei)\;ENU=Export of #1################# to #2#################\@3@@@@@@@@@@ records done.';
      Text30000@5157810 : TextConst 'DEU=#3##### SÑtze bearbeitet.;ENU=Export of #1################# to #2#################\@3@@@@@@@@@@ records done.';
      PortLineTest@5157802 : Record 5157806;
      BigLineTest@5157812 : BigText;
    BEGIN
      CLEARALL;

      Port.GET(PortCode);
      Port.TESTFIELD("File Name");
      MessageFilename := SetGlobals(Port."File Name");
      TableCaption := TestTable;

      PortLine.SETRANGE(Code,Port.Code);
      PortLine.SETRANGE("Processing Only",FALSE);
      IF NOT PortLine.FINDSET(FALSE,FALSE) THEN
        ERROR(Text002);

      PortLineTest.SETRANGE(Code,Port.Code);
      PortLineTest.SETFILTER("Filter to ignore",'<>%1','');
      IF PortLineTest.FINDFIRST THEN
        PreCheckNeeded := TRUE
      ELSE
        PreCheckNeeded := FALSE;

      PortLine.SETCURRENTKEY(Code,"Table No.",Position);
      MaxField := PortLine.COUNT;

      IF ISSERVICETIER THEN
        ServerFileName := FileMgt.ServerTempFileName('','txt')
      ELSE BEGIN
        exFile.QUERYREPLACE := TRUE;
        ServerFileName := Port."File Name";
      END;
      exFile.WRITEMODE := TRUE;

      XML := Port.XML;
      IF XML THEN
        ServerFileName += '.xml';

      IF NOT OPPLicenseInfo.IsStandard AND NOT OPPLicenseInfo.IsEnterprise THEN
        ERROR(Text027);

      IF NOT exFile.CREATE(ServerFileName) THEN
        exFile.OPEN(ServerFileName);
      exFile.CREATEOUTSTREAM(oStream);

      //H0581 06.03.2014  ARI ++++++++++++++++++++++++++++++++
      IF GUIALLOWED THEN
      //H0581 06.03.2014  ARI --------------------------------
        Window.OPEN(Text10000+Text20000+Text30000,TableCaption,MessageFilename,Exported);

      IF Port.ExportFieldNames THEN BEGIN
        ExportFieldNames(BigLine,MaxField);
        BigLine.WRITE(oStream);
      END;

      myRec.OPEN(Port."Table No.");

      // Filter
      PortLine.SETFILTER("Table No.",'<>%1',0);
      PortLine.SETFILTER(Filter,'<>%1','');
      IF PortLine.FIND('-') THEN REPEAT
        myField := myRec.FIELD(PortLine."Field No.");
        myField.SETFILTER(PortLine.Filter);
      UNTIL PortLine.NEXT = 0;

      PortLine.RESET;
      PortLine.SETCURRENTKEY(Code,"Table No.",Position);
      PortLine.SETRANGE(Code,Port.Code);
      PortLine.SETRANGE("Processing Only", FALSE);
      PortLine.SETFILTER("Table No.", '>%1', 0);
      PortLine.SETFILTER("Field No.", '>%1', 0);

      IF myRec.FIND('-') THEN BEGIN
        // xml
        IF XML THEN BEGIN
          IF ISCLEAR(xmlDoc) THEN
            CREATE(xmlDoc);
          xmlDoc.loadXML('<?xml version="1.0" encoding="UTF-8"?>');
          xmlNode1 := xmlDoc.createNode('Element', 'Table', '');
          IF XML THEN BEGIN
            xmlTool.SetNormalCase;
            xmlTool.AddAttribute(xmlNode1,'Name',Port."Table Caption");
            xmlDoc.appendChild(xmlNode1);
          END;
        END;
        // xml end

        MaxRec := myRec.COUNT;
        IF (Port.SkipLines + Port.DropLines >= MaxRec) AND NOT Port.ExportFieldNames THEN
          MESSAGE(Text025,TableCaption)
        ELSE IF (Port.SkipLines + Port.DropLines < MaxRec) THEN BEGIN
          IF Port.SkipLines > 0 THEN BEGIN
            REPEAT
              Exported += 1;
            UNTIL (Exported = Port.SkipLines) OR (myRec.NEXT=0);
          END;
          REPEAT
            Exported += 1;
            // xml
            IF XML THEN BEGIN
              xmlTool.AddElement(xmlNode1,'Record','','',xmlNode2);
              xmlTool.AddAttribute(xmlNode2,'Id',FORMAT(Exported));
              xmlNode1 := xmlNode2;
            END;
            ExportDataLine(myRec,BigLine,MaxField);
            // xml
            IF XML THEN
              xmlNode1 := xmlNode1.parentNode
            ELSE BEGIN
            // xml end
              IF PreCheckNeeded THEN BEGIN
                IF PreCheckFilter(BigLine) THEN BEGIN
                  BigLine.WRITE(oStream);
                END
              END ELSE
                BigLine.WRITE(oStream);
            END;
            IF (Exported MOD 10 = 0) THEN
              Window.UPDATE(3,Exported);
          UNTIL (Exported+Port.DropLines = MaxRec) OR (myRec.NEXT=0);
        END;
      END;

      myRec.CLOSE;
      exFile.CLOSE;
      CLEAR(myRec);
      CLEAR(OUTSTREAM);
      CLEAR(exFile);

      // xml
      IF XML THEN
        xmlDoc.save(ServerFileName);

      IF ISSERVICETIER THEN BEGIN
        FileMgt.DownloadToFile(ServerFileName,Port."File Name");
      END;
      IF Port.Logfile THEN
        LogFile(MessageFilename);

      //H0581 06.03.2014  ARI ++++++++++++++++++++++++++++++++
      IF GUIALLOWED THEN
      //H0581 06.03.2014  ARI --------------------------------
        Window.CLOSE;
    END;

    PROCEDURE ExportFieldNames@1140009(VAR BigLine@5157805 : BigText;Max@5157806 : Integer);
    VAR
      i@5157804 : Integer;
      Line@1140000 : Text[1024];
    BEGIN
      PortLine.FIND('-');
      CLEAR(BigLine);
      i := 0;
      REPEAT
        i += 1;
        Line := Delimiter;
        IF PortLine."Column Description" <> '' THEN
          Line += PortLine."Column Description"
        ELSE
          Line += PortLine."Field Name";
        Line += Delimiter;
        IF i < Max THEN
          Line += Separator;
        IF Port.Encoding = Port.Encoding::ANSI THEN
          Line := FinanceTools.Ascii2Ansi(Line);
        BigLine.ADDTEXT(Line);
      UNTIL PortLine.NEXT = 0;
      BigLine.ADDTEXT(CRLF);
    END;

    PROCEDURE ExportDataLine@1140000(myRecRef@5157805 : RecordRef;VAR BigLine@5157807 : BigText;Max@5157808 : Integer);
    VAR
      myField@1140001 : FieldRef;
      myDec@1140006 : Decimal;
      myBool@1140007 : Boolean;
      i@5157804 : Integer;
      myInt@1140008 : Integer;
      myDate@1140009 : Date;
      FieldText@1140000 : Text[255];
      TempText@5157803 : Text[510];
      LocalDelimiter@5157802 : Text[1];
    BEGIN
      PortLine.FIND('-');
      CLEAR(BigLine);
      i := 0;

      REPEAT

        All.GET(PortLine."Table No.",PortLine."Field No.");
        myField := myRecRef.FIELD(PortLine."Field No.");
        i += 1;

        IF All.Class = All.Class::FlowField THEN
          myField.CALCFIELD;

        CASE All.Type OF

          All.Type::Boolean: BEGIN
            CLEAR(FieldText);
            myBool := myField.VALUE;
            CASE Port.BoolFormat OF
              Port.BoolFormat::"Ja/Nein": IF myBool THEN FieldText := 'Ja' ELSE FieldText := 'Nein';
              Port.BoolFormat::"Yes/No": IF myBool THEN FieldText := 'Yes' ELSE FieldText := 'No';
              Port.BoolFormat::"Wahr/Falsch": IF myBool THEN FieldText := 'Wahr' ELSE FieldText := 'Falsch';
              Port.BoolFormat::"True/False": IF myBool THEN FieldText := 'True' ELSE FieldText := 'False';
              Port.BoolFormat::"0/1": IF myBool THEN FieldText := '1' ELSE FieldText := '0';
            ELSE
              FieldText := FORMAT(myField.VALUE);
            END;
            CASE Port.BoolCase OF
              Port.BoolCase::Upper: FieldText := UPPERCASE(FieldText);
              Port.BoolCase::Lower: FieldText := LOWERCASE(FieldText);
            END;
          END;

          All.Type::Decimal:
            BEGIN
              myType := myType::Decimal;
              EVALUATE(myDec,FORMAT(myField.VALUE));

              IF PortLine.Factor <> 0 THEN
                myDec := myDec * PortLine.Factor;
              IF PortLine."Inc/Dec" <> 0 THEN
                myDec += PortLine."Inc/Dec";

              IF PortLine.Amounts = PortLine.Amounts::Absolute THEN BEGIN
                IF myDec < 0 THEN
                  myDec := myDec *-1;
              END ELSE IF PortLine.Amounts = PortLine.Amounts::Invert THEN
                myDec := myDec *-1
              ELSE IF PortLine.Amounts = PortLine.Amounts::Default THEN BEGIN
                IF Port.Amounts = Port.Amounts::Absolute THEN BEGIN
                  IF myDec < 0 THEN
                    myDec := myDec *-1;
                END ELSE IF Port.Amounts = Port.Amounts::Invert THEN
                  myDec := myDec *-1;
              END;

              FieldText := myFormat(0D,myDec,0);
            END;

          All.Type::Integer:
            BEGIN
              myType := myType::Integer;
              EVALUATE(myInt,FORMAT(myField.VALUE));
              IF PortLine."Inc/Dec" <> 0 THEN
                myInt += PortLine."Inc/Dec";
              IF PortLine.Amounts = PortLine.Amounts::Absolute THEN BEGIN
                IF myInt < 0 THEN
                  myInt := myInt *-1;
              END ELSE IF PortLine.Amounts = PortLine.Amounts::Invert THEN
                myInt := myInt *-1
              ELSE IF PortLine.Amounts = PortLine.Amounts::Default THEN BEGIN
                IF Port.Amounts = Port.Amounts::Absolute THEN BEGIN
                  IF myInt < 0 THEN
                    myInt := myInt *-1;
                END ELSE IF Port.Amounts = Port.Amounts::Invert THEN
                  myInt := myInt *-1;
              END;
              FieldText := myFormat(0D,0,myInt);
            END;

          All.Type::Date:
            BEGIN
              myType := myType::Date;
              EVALUATE(myDate,FORMAT(myField.VALUE));
              IF PortLine."Inc/Dec" <> 0 THEN
                myDate := CALCDATE(FORMAT(PortLine."Inc/Dec")+'T',myDate);
              FieldText := myFormat(myDate,0,0);
            END;

          ELSE BEGIN
            FieldText := FORMAT(myField.VALUE);
            IF PortLine.TextCase = PortLine.TextCase::Upper THEN
              FieldText:= UPPERCASE(FieldText)
            ELSE IF PortLine.TextCase = PortLine.TextCase::Lower THEN
              FieldText:= UPPERCASE(FieldText)
            ELSE IF PortLine.TextCase = PortLine.TextCase::Default THEN BEGIN
              IF Port.TextCase = Port.TextCase::upper THEN
                FieldText:= UPPERCASE(FieldText)
              ELSE IF Port.TextCase = Port.TextCase::lower THEN
                FieldText:= LOWERCASE(FieldText);
            END;
          END;

        END; // case

      // Postprocessing

        TempText := FieldText;

        IF PortLine.LeftDrop > 0 THEN BEGIN
          IF STRLEN(TempText) > PortLine.LeftDrop THEN
            TempText := COPYSTR(TempText,PortLine.LeftDrop+1);
        END;

        IF PortLine.RightDrop > 0 THEN BEGIN
          IF STRLEN(TempText) >= PortLine.RightDrop THEN
            TempText := COPYSTR(TempText,1,STRLEN(TempText)-PortLine.RightDrop);
        END;

        IF PortLine.ContentLength > 0 THEN BEGIN
          IF STRLEN(TempText) >= PortLine.ContentLength THEN
            TempText := COPYSTR(TempText,1,PortLine.ContentLength);
        END;

        IF PortLine."Space before Field" THEN
          TempText += ' ';

        IF PortLine."Space after Field" THEN
          TempText += ' ';

        IF PortLine.Colwidth > 0 THEN BEGIN
          IF STRLEN(TempText) > PortLine.Colwidth THEN
            TempText := COPYSTR(TempText,1,PortLine.Colwidth)
          ELSE IF STRLEN(TempText) < PortLine.Colwidth THEN BEGIN
            IF PortLine.PadChar = '' THEN
              PortLine.PadChar[1] := 32;
            IF PortLine.Padding = PortLine.Padding::Left THEN BEGIN
              WHILE STRLEN(TempText) < PortLine.Colwidth DO
                TempText := PortLine.PadChar + TempText;
            END ELSE
              TempText := PADSTR(TempText,PortLine.Colwidth,PortLine.PadChar);
          END;
        END;

        TempText := PortLine."Text before" + TempText + PortLine."Text after";

        // xml
        IF XML THEN
          xmlTool.AddElement(xmlNode1,'fld'+FORMAT(PortLine."Field No."),TempText,'',xmlNode2)
        ELSE BEGIN
          // xml end
          IF NOT Port.FixCol THEN BEGIN
            IF Delimiter <> '' THEN
              TempText := Delimiter + TempText + Delimiter
            ELSE BEGIN
              IF STRPOS(TempText,Separator) > 0 THEN
                TempText := '"' +  TempText + '"';
            END;
            IF i < Max THEN
              TempText += Separator;
          END;

          IF Port.Encoding = Port.Encoding::ANSI THEN
            TempText := FinanceTools.Ascii2Ansi(TempText);

          IF Port.FixCol THEN BEGIN
            WHILE BigLine.LENGTH < PortLine.StartPos DO
              BigLine.ADDTEXT(' ');
            BigLine.ADDTEXT(TempText,PortLine.StartPos)
          END ELSE
            BigLine.ADDTEXT(TempText);
           // xml
        END;

      UNTIL PortLine.NEXT = 0;

      BigLine.ADDTEXT(CRLF);
    END;

    PROCEDURE CSVPortImpEx@5157805(CSVPort@5157803 : Record 5157805;CodeVar@5157816 : Code[20];Export@5157811 : Boolean) : Integer;
    VAR
      CSVHeader@5157802 : Record 5157805;
      CSVLine@5157804 : Record 5157806;
      RecRef@5157805 : RecordRef;
      f@5157821 : File;
      GoOn@5157819 : Boolean;
      PortCode@5157817 : Code[20];
      FRef@5157806 : FieldRef;
      iStream@5157818 : InStream;
      i@5157815 : Integer;
      HeaderTableNo@5157809 : Integer;
      LineTableNo@5157810 : Integer;
      Pos@5157813 : Integer;
      LocCounter@5157812 : Integer;
      Line@5157814 : Text[1024];
      TempStr@5157808 : Text[1024];
      FilePath@5157807 : Text[250];
      Field1@5157820 : FieldRef;
    BEGIN
      IF Export THEN
        FilePath := CommonDlgMgt.OpenFile(Text015,FilePath,4,Text003,1)
      ELSE
        FilePath := CommonDlgMgt.OpenFile(Text016,FilePath,4,Text003,0);
      IF FilePath = '' THEN
        EXIT;
      MessageFilename := SetGlobals(FilePath);

      Objects.SETRANGE(Type,Objects.Type::Table);
      Objects.SETRANGE(Name,CSVHeader.TABLENAME);
      Objects.FIND('-');
      HeaderTableNo := Objects.ID;
      Objects.SETRANGE(Name,CSVLine.TABLENAME);
      Objects.FIND('-');
      LineTableNo := Objects.ID;

      IF Export THEN BEGIN
        IF CodeVar <> '' THEN
          CSVPort.SETRANGE(Code,CodeVar);
        IF CSVPort.FINDSET(FALSE,FALSE) THEN BEGIN
          IF ISSERVICETIER THEN
            ServerFileName := FileMgt.ServerTempFileName('','txt')
          ELSE BEGIN
            ServerFileName := FilePath;
            f.QUERYREPLACE := FALSE;
          END;
          f.TEXTMODE := TRUE;
          f.WRITEMODE := TRUE;
          f.CREATE(ServerFileName);
          REPEAT
            PortCode := CSVPort.Code;
            WITH RecRef DO BEGIN
              OPEN(HeaderTableNo);
              FRef := FIELD(1);
              FRef.SETRANGE(PortCode);
              FIND('-');
              Line := '';
              FOR i := 1 TO FIELDCOUNT DO BEGIN
                Field1 := FIELDINDEX(i);
                Line += FORMAT(Field1.VALUE);
                IF i < FIELDCOUNT THEN
                  Line += TAB;
              END;
              f.WRITE(Line);
              CLOSE;

              OPEN(LineTableNo);
              FRef := FIELD(1);
              FRef.SETRANGE(PortCode);
              IF FINDSET(FALSE,FALSE) THEN BEGIN
                REPEAT
                  Line := '';
                  FOR i := 1 TO FIELDCOUNT DO BEGIN
                    Field1 := FIELDINDEX(i);
                    Line += FORMAT(Field1.VALUE);
                    IF i < FIELDCOUNT THEN
                      Line += TAB;
                  END;
                  f.WRITE(Line);
                UNTIL NEXT=0;
              END;
              CLOSE;
            END;
            LocCounter += 1;
          UNTIL CSVPort.NEXT = 0;
          f.CLOSE;
          MESSAGE(Text013, LocCounter, MessageFilename);
        END;
      END ELSE BEGIN
        // Import
        IF ISSERVICETIER THEN BEGIN
          IF NOT FileMgt.SilentUpload(FilePath,ServerFileName) THEN
            ERROR(Text023,MessageFilename);
        END ELSE
          ServerFileName := FilePath;

        f.WRITEMODE := FALSE;
        f.OPEN(ServerFileName);
        f.CREATEINSTREAM(iStream);
        PortCode := '';

        WHILE NOT iStream.EOS DO BEGIN
          iStream.READTEXT(Line);
          Pos := STRPOS(Line,TAB);
          TempStr := COPYSTR(Line,1,Pos-1);
          Line := COPYSTR(Line,Pos+1);

          IF TempStr <> PortCode THEN BEGIN
            // Ports eintragen
            LocCounter += 1;
            PortCode := TempStr;
            RecRef.OPEN(HeaderTableNo);
            FRef := RecRef.FIELD(1);
            FRef.VALUE := PortCode;
            FOR i := 2 TO RecRef.FIELDCOUNT DO BEGIN
              Pos := STRPOS(Line,TAB);
              IF Pos > 0 THEN BEGIN
                TempStr := COPYSTR(Line,1,Pos-1);
                Line := COPYSTR(Line,Pos+1);
              END ELSE
                TempStr := Line;
              IF STRLEN(TempStr) > 0 THEN BEGIN
                FRef := RecRef.FIELDINDEX(i);
                FillField(FRef,TempStr);
              END;
            END;
            IF RecRef.INSERT THEN BEGIN
              "Records Inserted" +=1;
              GoOn := TRUE;
            END ELSE BEGIN
              "Records Skipped" +=1;
              GoOn := FALSE;
            END;
            RecRef.CLOSE;
          END ELSE BEGIN
            IF GoOn THEN BEGIN
              // Insert lines
              RecRef.OPEN(LineTableNo);
              FRef := RecRef.FIELDINDEX(1);
              FRef.VALUE := PortCode;
              FOR i := 2 TO RecRef.FIELDCOUNT DO BEGIN
                Pos := STRPOS(Line,TAB);
                IF Pos > 0 THEN BEGIN
                  TempStr := COPYSTR(Line,1,Pos-1);
                  Line := COPYSTR(Line,Pos+1);
                END ELSE
                  TempStr := Line;

                IF STRLEN(TempStr) > 0 THEN BEGIN
                  FRef := RecRef.FIELDINDEX(i);
                  FillField(FRef,TempStr);
                END;
              END;
              RecRef.INSERT;
              RecRef.CLOSE;
            END;
          END;
        END;
        f.CLOSE;
        CLEAR(f);
        MESSAGE(Text014, LocCounter, "Records Inserted", "Records Skipped");
      END;

      EXIT("Records Inserted");
    END;

    PROCEDURE RestoreStandardInterfaces@5157802(IsBatch@5157810 : Boolean);
    VAR
      Ports@5157805 : ARRAY [3] OF Code[20];
      Process@5157802 : ARRAY [3] OF Code[20];
      i@5157803 : Integer;
      Inserted@5157807 : Integer;
      Modified@5157808 : Integer;
    BEGIN
      Objects.SETRANGE(Type,Objects.Type::Table);
      Objects.SETRANGE(Name,PmtImportLine.TABLENAME);
      Objects.FIND('-');
      PmtEntryTableID := Objects.ID;
      All.SETRANGE(TableNo,PmtEntryTableID);

      Inserted := 0;
      Modified := 0;
      CLEAR(Process);
      EVALUATE(Ports[1],'Multicash');
      EVALUATE(Ports[2],'SFirm-I');  // umsatze.txt
      EVALUATE(Ports[3],'SFirm-II'); // umsatz.txt = ELKO erweitert

      FOR i := 1 TO 3 DO BEGIN
        Port.INIT;
        Port.Code := Ports[i];
        Port.Description := COPYSTR(STRSUBSTNO(Text009,Ports[i]),1,MAXSTRLEN(Port.Description));
        Port.VALIDATE(BankImport,TRUE);
        IF Port.INSERT THEN BEGIN
          Inserted += 1;
          Process[i] := Ports[i];
        END ELSE IF IsBatch THEN BEGIN
          Process[i] := 'x';
        END ELSE IF CONFIRM(Text008,FALSE,Ports[i]) THEN BEGIN
          Port.MODIFY;
          Modified +=1;
          PortLine.SETRANGE(Code,Port.Code);
          PortLine.DELETEALL;
          Process[i] := Ports[i];
        END;
      END;

      IF Process[1] = Ports[1] THEN BEGIN
        Port.GET(Process[1]);
        i := 1;
        StdLine(i,'Bank-ID');
        StdLine(i,'Bank Account-ID');
        StdLine(i,'Currency-ID');
        StdLine(i,'Statement No.');
        StdLine(i,'Value Date');
        StdLine(i,'Posting Date');
        StdLine(i,'Reference');
        StdLine(i,'Text Code');
        StdLine(i,'Amount');
        StdLine(i,'Posting Description');
        StdLine(i,'Reason Row 1');
        StdLine(i,'Reason Row 2');
        StdLine(i,'Reason Row 3');
        StdLine(i,'Reason Row 4');
        StdLine(i,'Reason Row 5');
        StdLine(i,'Reason Row 6');
        StdLine(i,'Reason Row 7');
        StdLine(i,'Reason Row 8');
        StdLine(i,'Reason Row 9');
        StdLine(i,'Reason Row 10');
        StdLine(i,'Reason Row 11');
        StdLine(i,'Reason Row 12');
        StdLine(i,'Reason Row 13');
        StdLine(i,'Reason Row 14');
        StdLine(i,'Additional Info');
        StdLine(i,'Additional Info 2');
        StdLine(i,'Orderer');
        StdLine(i,'Orderer 2');
        StdLine(i,'Bank Orderer');
        StdLine(i,'Account Orderer');
      END;

      IF Process[2] = Ports[2] THEN BEGIN
        Port.GET(Process[2]);
        i := 1;
        StdLine(i,'Bank-ID');
        StdLine(i,'Bank Account-ID');
        StdLine(i,'Statement No.');
        StdLine(i,'Value Date');
        StdLine(i,'Prima Nota');
        StdLine(i,'Reason Row 1');
        StdLine(i,'Posting Description');
        StdLine(i,'Time');
        StdLine(i,'Text Code');
        StdLine(i,'Check No.');
        StdLine(i,'Amount');
        StdLine(i,'Platzhalter');
        StdLine(i,'Platzhalter');
        StdLine(i,'Posting Date');
        StdLine(i,'Additional Info');
        StdLine(i,'Additional Info 2');
        StdLine(i,'Reason Row 2');
        StdLine(i,'Reason Row 3');
        StdLine(i,'Reason Row 4');
        StdLine(i,'Reason Row 5');
        StdLine(i,'Reason Row 6');
        StdLine(i,'Reason Row 7');
        StdLine(i,'Reason Row 8');
        StdLine(i,'Reason Row 9');
        StdLine(i,'Reason Row 10');
        StdLine(i,'Reason Row 11');
        StdLine(i,'Reason Row 12');
        StdLine(i,'Reason Row 13');
        StdLine(i,'Reason Row 14');
        StdLine(i,'Orderer');
        StdLine(i,'Orderer 2');
        StdLine(i,'Account Orderer');
        StdLine(i,'Bank Orderer');
        StdLine(i,'Business Case Code');
        StdLine(i,'Reversal-ID');
      END;

      IF Process[3] = Ports[3] THEN BEGIN
        Port.GET(Process[3]);
        i := 1;
        StdLine(i,'Bank-ID');
        StdLine(i,'Bank Account-ID');
        StdLine(i,'Statement No.');
        StdLine(i,'Value Date');
        StdLine(i,'Prima Nota');
        StdLine(i,'Reason Row 1');
        StdLine(i,'Posting Description');
        StdLine(i,'[LEER]');
        StdLine(i,'Text Code');
        StdLine(i,'Check No.');
        StdLine(i,'Amount');
        StdLine(i,'[LEER]');
        StdLine(i,'[LEER]');
        StdLine(i,'Posting Date');
        StdLine(i,'[LEER]');
        StdLine(i,'[LEER]');
        StdLine(i,'Reason Row 2');
        StdLine(i,'Reason Row 3');
        StdLine(i,'Reason Row 4');
        StdLine(i,'Reason Row 5');
        StdLine(i,'Reason Row 6');
        StdLine(i,'Reason Row 7');
        StdLine(i,'Reason Row 8');
        StdLine(i,'Reason Row 9');
        StdLine(i,'Reason Row 10');
        StdLine(i,'Reason Row 11');
        StdLine(i,'Reason Row 12');
        StdLine(i,'Reason Row 13');
        StdLine(i,'Reason Row 14');
        StdLine(i,'Orderer');
        StdLine(i,'Orderer 2');
        StdLine(i,'Account Orderer');
        StdLine(i,'Bank Orderer');
        StdLine(i,'Business Case Code');
        StdLine(i,'[LEER]');
        StdLine(i,'Posting Date');
        StdLine(i,'Konstante1');
        StdLine(i,'Konstante2');
        StdLine(i,'Konstante3');
        StdLine(i,'Konstante4');
        StdLine(i,'Konstante5');
        StdLine(i,'Kontobezeichnung');
        StdLine(i,'Kontoinhaber');
        StdLine(i,'Kontoklasse');
        StdLine(i,'Lfd. Nummer');
        StdLine(i,'[LEER]');
        StdLine(i,'[LEER]');
        StdLine(i,'Schlu·saldo');
        StdLine(i,'Startsaldo');
        StdLine(i,'Reversal-ID');
        StdLine(i,'[LEER]');
        StdLine(i,'[LEER]');
        StdLine(i,'Text Code Supplement');
        StdLine(i,'Origin Amount');
        StdLine(i,'Origin Currency');
        StdLine(i,'Currency-ID');
      END;
      IF NOT IsBatch THEN
        MESSAGE(Text010, ARRAYLEN(Ports),Inserted,Modified);
    END;

    PROCEDURE StdLine@5157803(VAR i@5157806 : Integer;Field_Name@5157803 : Text[80]);
    BEGIN
      WITH PortLine DO BEGIN
        INIT;
        Code := Port.Code;
        "Table No." := PmtEntryTableID;
        "Line No." := 10000 + i*10;
        Position := "Line No.";
        All.SETRANGE(FieldName,Field_Name);
        IF All.FIND('-') THEN
          VALIDATE("Field No.",All."No.")
        ELSE
          "Column Description" := COPYSTR(Text019 + Field_Name + '>',1,MAXSTRLEN("Column Description"));
        INSERT;
      END;
      i += 1;
    END;

    PROCEDURE CopyInterface@1140006(Rec@1140000 : Record 5157805) : Code[20];
    VAR
      Rec2@1140001 : Record 5157805;
      PortLine2@1140002 : Record 5157806;
      NewCode@5157802 : Code[20];
      Text10000@5157803 : TextConst 'DEU=" (Kopie)";ENU=" (Copy)"';
    BEGIN
      NewCode := COPYSTR(Rec.Code,1,MAXSTRLEN(Rec.Code)-STRLEN(Text10000)) + Text10000;
      PortLine.SETRANGE(Code,Rec.Code);
      IF PortLine.FINDSET(FALSE,FALSE) THEN REPEAT
        PortLine2.COPY(PortLine);
        PortLine2.Code := NewCode;
        PortLine2.INSERT;
      UNTIL PortLine.NEXT=0;

      Rec2.COPY(Rec);
      Rec2.Code := NewCode;
      Rec2.INSERT;

      EXIT(NewCode);
    END;

    PROCEDURE myFormat@1140004(DatePara@1140003 : Date;DecPara@1140000 : Decimal;IntPara@1140001 : Integer) : Text[30];
    BEGIN
      CASE myType OF

        // Date
        myType::Date: BEGIN
          IF PortLine.Formatstring <> '' THEN
            EXIT(FORMAT(DatePara,0,PortLine.Formatstring))
          ELSE IF Port."Format Date" <> '' THEN
            EXIT(FORMAT(DatePara,0,Port."Format Date"))
          ELSE
            EXIT(FORMAT(DatePara));
        END;

        // Decimal
        myType::Decimal: BEGIN
          IF DecPara <> 0 THEN BEGIN
            IF PortLine.Formatstring <> '' THEN
              EXIT(FORMAT(DecPara,0,PortLine.Formatstring))
            ELSE IF Port."Format Decimals" <> '' THEN
              EXIT(FORMAT(DecPara,0,Port."Format Decimals"))
            ELSE
              EXIT(FORMAT(DecPara));
          END ELSE
            IF Port.Zero2Text THEN
              EXIT('')
            ELSE
              EXIT('0');
        END;

        // Integer
        myType::Integer: BEGIN
          IF IntPara <> 0 THEN BEGIN
            IF PortLine.Formatstring <> '' THEN
              EXIT(FORMAT(IntPara,0,PortLine.Formatstring))
            ELSE
              EXIT(FORMAT(IntPara));
          END ELSE
            IF Port.Zero2Text THEN
              EXIT('')
            ELSE
              EXIT('0');
        END;
      END;
    END;

    PROCEDURE MakeDate@1140005(TextIn@1140000 : Text[30]) Result : Date;
    VAR
      Pos@1140001 : Integer;
      YearPos@1140007 : Integer;
      MonthPos@1140008 : Integer;
      DayPos@1140009 : Integer;
      Year@1140010 : Integer;
      Month@1140004 : Integer;
      Day@1140005 : Integer;
      FormatString@1140006 : Text[50];
    BEGIN
      // MakeDate ---------------------------------------- begin
      FormatString := DELCHR(PortLine.Formatstring,'<>');
      IF FormatString = '' THEN
        FormatString := DELCHR(Port."Format Date",'<>');

      IF (FormatString = '') OR (STRPOS(PortLine.Formatstring,SearchStr1) > 0) OR (STRPOS(PortLine.Formatstring,SearchStr2) > 0) THEN
      // MakeDate ---------------------------------------- end
        IF EVALUATE(Result,TextIn) THEN
          EXIT (Result);

      TextIn := CONVERTSTR(TextIn,' :-,/|', '......');

      IF (STRPOS(TextIn, '30.2.') > 0) OR (STRPOS(TextIn,'.2.30.')>0) THEN;
      // MakeDate ---------------------------------------- begin
      IF FormatString = '' THEN
      // MakeDate ---------------------------------------- end
        IF EVALUATE(Result,TextIn) THEN
          EXIT (Result);
      // MakeDate ---------------------------------------- begin
      // moved to top:
      // FormatString := DELCHR(PortLine.Formatstring,'<>');
      // IF FormatString = '' THEN
      //   FormatString := DELCHR(Port."Format Date",'<>');
      // MakeDate ---------------------------------------- end
      IF FormatString <> '' THEN
        FormatString := LOWERCASE(CONVERTSTR(FormatString,' :-,/|','......'))
      ELSE
        EXIT(0D);

      YearPos := STRPOS(FormatString,'year');
      MonthPos := STRPOS(FormatString,'month');
      DayPos := STRPOS(FormatString,'day');
      IF YearPos + MonthPos + DayPos = 0 THEN
        EXIT(0D);

      // Year, Day, Month
      IF (YearPos>0) AND (MonthPos>0) AND (DayPos>0) THEN BEGIN

        // a) Separator found
        Pos := STRPOS(TextIn,'.');

        IF Pos > 0 THEN BEGIN
          // Year first
          IF YearPos < MonthPos THEN BEGIN
            EVALUATE(Year,COPYSTR(TextIn,1,Pos-1));
            TextIn := COPYSTR(TextIn,Pos+1);
            Pos := STRPOS(TextIn,'.');
            IF MonthPos < DayPos THEN BEGIN
              EVALUATE(Month,COPYSTR(TextIn,1,Pos-1));
              EVALUATE(Day,COPYSTR(TextIn,Pos+1));
            END ELSE BEGIN
              EVALUATE(Day,COPYSTR(TextIn,1,Pos-1));
              EVALUATE(Month,COPYSTR(TextIn,Pos+1));
            END;
          // Year last
          END ELSE BEGIN
            IF MonthPos < DayPos THEN BEGIN
              EVALUATE(Month,COPYSTR(TextIn,1,Pos-1));
              TextIn := COPYSTR(TextIn,Pos+1);
              Pos := STRPOS(TextIn,'.');
              EVALUATE(Day,COPYSTR(TextIn,1,Pos-1));
              EVALUATE(Year,COPYSTR(TextIn,Pos+1));
            END ELSE BEGIN
              EVALUATE(Day,COPYSTR(TextIn,1,Pos-1));
              TextIn := COPYSTR(TextIn,Pos+1);
              Pos := STRPOS(TextIn,'.');
              EVALUATE(Month,COPYSTR(TextIn,1,Pos-1));
              EVALUATE(Year,COPYSTR(TextIn,Pos+1));
            END;
          END;

        // b) no Separator
        //    Date will have 6 or 8 digits
        END ELSE BEGIN
          IF STRLEN(TextIn) = 8 THEN BEGIN
            // Year first
            IF YearPos < MonthPos THEN BEGIN
              EVALUATE(Year,COPYSTR(TextIn,1,4));
              IF MonthPos < DayPos THEN BEGIN
                EVALUATE(Month,COPYSTR(TextIn,5,2));
                EVALUATE(Day,COPYSTR(TextIn,7,2));
              END ELSE BEGIN
                EVALUATE(Day,COPYSTR(TextIn,5,2));
                EVALUATE(Month,COPYSTR(TextIn,7,2));
              END;
            // Year last
            END ELSE BEGIN
              EVALUATE(Year,COPYSTR(TextIn,5,4));
              IF MonthPos < DayPos THEN BEGIN
                EVALUATE(Month,COPYSTR(TextIn,1,2));
                EVALUATE(Day,COPYSTR(TextIn,3,2));
              END ELSE BEGIN
                EVALUATE(Day,COPYSTR(TextIn,1,2));
                EVALUATE(Month,COPYSTR(TextIn,3,2));
              END;
            END;
          END ELSE IF STRLEN(TextIn) = 6 THEN BEGIN
          // Year first
            IF YearPos < MonthPos THEN BEGIN
              EVALUATE(Year,'20' + COPYSTR(TextIn,1,2)); //this Century should be enough
              IF MonthPos < DayPos THEN BEGIN
                EVALUATE(Month,COPYSTR(TextIn,5,2));
                EVALUATE(Day,COPYSTR(TextIn,7,2));
              END ELSE BEGIN
                EVALUATE(Day,COPYSTR(TextIn,5,2));
                EVALUATE(Month,COPYSTR(TextIn,7,2));
              END;
            // Year last
            END ELSE BEGIN
              EVALUATE(Year,'20' + COPYSTR(TextIn,5,2));
              IF MonthPos < DayPos THEN BEGIN
                EVALUATE(Month,COPYSTR(TextIn,1,2));
                EVALUATE(Day,COPYSTR(TextIn,3,2));
              END ELSE BEGIN
                EVALUATE(Day,COPYSTR(TextIn,1,2));
                EVALUATE(Month,COPYSTR(TextIn,3,2));
                END;
              END;
            // do nothing
          END;
        END;
      END;

      // Year, Month only
      IF (YearPos>0) AND (MonthPos>0) AND (DayPos=0) THEN BEGIN
        Pos := STRPOS(TextIn,'.');
        IF Pos = 0 THEN BEGIN
          IF YearPos > DayPos THEN BEGIN
            EVALUATE(Year,'20' + COPYSTR(TextIn,1,Pos-1));
            EVALUATE(Month,COPYSTR(TextIn,Pos+1));
          END ELSE BEGIN
            EVALUATE(Month,COPYSTR(TextIn,1,Pos-1));
            EVALUATE(Year,'20' + COPYSTR(TextIn,Pos+1));
          END;
        END ELSE BEGIN
          // No Separator, date will probably have 4 digits
          IF YearPos > DayPos THEN BEGIN
            EVALUATE(Year,'20' + COPYSTR(TextIn,1,2));
            EVALUATE(Month,COPYSTR(TextIn,3,2));
          END ELSE BEGIN
            EVALUATE(Month,COPYSTR(TextIn,1,2));
            EVALUATE(Year,'20' + COPYSTR(TextIn,3,2));
          END;
        END;
      END;

      // Day,Month only
      IF (YearPos=0) AND (MonthPos>0) AND (DayPos>0) THEN BEGIN
        Pos := STRPOS(TextIn,'.');
        IF Pos > 0 THEN BEGIN
          IF MonthPos > DayPos THEN BEGIN
            EVALUATE(Day,COPYSTR(TextIn,1,Pos-1));
            EVALUATE(Month,COPYSTR(TextIn,Pos+1));
          END ELSE BEGIN
            EVALUATE(Month,COPYSTR(TextIn,1,Pos-1));
            EVALUATE(Day,COPYSTR(TextIn,Pos+1));
          END;
        END ELSE BEGIN
          // No Separator, date will probably have 4 digits
          IF MonthPos > DayPos THEN BEGIN
            EVALUATE(Day,COPYSTR(TextIn,1,2));
            EVALUATE(Month,COPYSTR(TextIn,3,2));
          END ELSE BEGIN
            EVALUATE(Month,COPYSTR(TextIn,1,2));
            EVALUATE(Day,COPYSTR(TextIn,3,2));
          END;
        END;
      END;

      // Day only
      IF (YearPos=0) AND (MonthPos=0) AND (DayPos>0) THEN
        EVALUATE(Day,TextIn);

      IF Year = 0 THEN
        Year := DATE2DMY(TODAY,3);
      IF Month = 0 THEN
        Month := DATE2DMY(TODAY,2);
      IF Day =0 THEN
        Day := DATE2DMY(TODAY,1);
      //+++
      Result := DMY2DATE(Day,Month,Year);
    END;

    PROCEDURE GetColsFromTable@1140007(PortCode@1140000 : Code[20];Append@5157802 : Boolean);
    VAR
      LineNo@1140001 : Integer;
    BEGIN
      LineNo := PrepareTables(PortCode,Append);
      IF LineNo < 1 THEN
        EXIT;
      IF Append THEN
        LineNo += 1;

      All.SETRANGE(TableNo,Port."Table No.");
      IF All.FIND('-') THEN BEGIN
        REPEAT
          PortLine.INIT;
          PortLine.Code := Port.Code;
          PortLine."Table No." := Port."Table No.";
          PortLine."Line No." := LineNo;
          PortLine.Position := LineNo;
          PortLine.VALIDATE("Field No.",All."No.");
          PortLine.INSERT(FALSE);
          LineNo +=1;
        UNTIL All.NEXT=0;
      END;
    END;

    PROCEDURE GetColsFromFile@1140008(PortCode@1140008 : Code[20];Append@5157803 : Boolean);
    VAR
      f@5157807 : File;
      iStream@1140011 : InStream;
      BigLine@5157809 : BigText;
      BigLine2@5157811 : BigText;
      Max@5157808 : Integer;
      LineNo@1140002 : Integer;
      i@5157802 : Integer;
      n@5157810 : Integer;
      Pos@1140003 : Integer;
      TempText@5157805 : Text[1024];
    BEGIN
      LineNo := PrepareTables(PortCode,Append);
      IF LineNo < 1 THEN
        EXIT;
      IF Append THEN
        LineNo += 1;

      MessageFilename := SetGlobals(Port."File Name");
      IF NOT FinanceTools.fsExists(Port."File Name") THEN
        ERROR(Text001,MessageFilename)
      ELSE BEGIN
        IF ISSERVICETIER THEN BEGIN
          ServerFileName := FileMgt.ServerTempFileName('','txt');
          IF NOT FileMgt.SilentUpload(Port."File Name",ServerFileName) THEN
            ERROR(Text023,MessageFilename);
        END ELSE
          ServerFileName := Port."File Name";
      END;

      Max := MAXSTRLEN(TempText);
      f.WRITEMODE := FALSE;
      f.OPEN(ServerFileName);
      f.CREATEINSTREAM(iStream);

      WHILE i < Port.SkipLines DO BEGIN
        n := iStream.READTEXT(TempText,Max);
        IF n < Max THEN
          i += 1;
      END;
      i := 0;
      REPEAT
        n := iStream.READTEXT(TempText);
        BigLine.ADDTEXT(TempText);
      UNTIL n < Max;

      BigLine.GETSUBTEXT(TempText,1,1);
      IF TempText = COLON THEN BEGIN
        Port.Delimiter := Port.Delimiter::single;
        Delimiter := ''''
      END ELSE IF TempText = '"' THEN BEGIN
        Port.Delimiter := Port.Delimiter::double;
        Delimiter := '"';
      END ELSE
        Delimiter := '';
      IF Port.Separator = '' THEN
        Port.Separator := TAB;
      Port.MODIFY;

      REPEAT
      CLEAR(TempText);
        Pos := BigLine.TEXTPOS(Delimiter+Port.Separator);
        IF Pos > 0 THEN BEGIN
          BigLine.GETSUBTEXT(TempText,1,Pos-1);
          IF Delimiter = '' THEN
            BigLine.GETSUBTEXT(BigLine2,Pos+1)
          ELSE
            BigLine.GETSUBTEXT(BigLine2,Pos+2);
          CLEAR(BigLine);
          BigLine := BigLine2;
          CLEAR(BigLine2);
        END ELSE BEGIN
          BigLine.GETSUBTEXT(TempText,1);
          TempText := DELCHR(TempText,'<>',Separator);
        END;

        TempText := DELCHR(TempText,'<>',Delimiter);
        IF Port.Encoding = Port.Encoding::ANSI THEN
          TempText := FinanceTools.Ansi2Ascii(TempText);
        PortLine.INIT;
        PortLine.Code := Port.Code;
        PortLine."Table No." := Port."Table No.";
        PortLine."Line No." := LineNo;
        PortLine.Position := LineNo;
        PortLine."Column Description" :=  DELCHR(COPYSTR(TempText,1,MAXSTRLEN(PortLine."Column Description")),'<>',Delimiter);
        PortLine.INSERT(FALSE);
        LineNo += 1;
      UNTIL Pos < 1;

      CLEAR(iStream);
      f.CLOSE;
    END;

    PROCEDURE GetColsFromUser@5157809(PortCode@5157802 : Code[20];Append@5157804 : Boolean);
    VAR
      Lines@5157806 : Integer;
      LineNo@5157803 : Integer;
      i@5157805 : Integer;
      Text10000@5157807 : TextConst 'DEU=5 Spalten, 10 Spalten, 20 Spalten;ENU=5 Columns, 10 Columns, 20 Columns';
    BEGIN
      LineNo := PrepareTables(PortCode,Append);
      IF LineNo < 1 THEN
        EXIT;
      IF Append THEN
        LineNo += 1;

      Lines := STRMENU(Text10000,1);
      CASE Lines OF
        1: Lines := 5;
        2: Lines := 10;
        3: Lines := 20;
      END;

      FOR i := 1 TO Lines DO BEGIN
        PortLine.INIT;
        PortLine.Code := Port.Code;
        PortLine."Table No." := Port."Table No.";
        PortLine."Line No." := LineNo;
        PortLine.Position := LineNo;
        PortLine.INSERT(FALSE);
        LineNo += 1;
      END;
    END;

    PROCEDURE LogFile@1140015(Filename@5157803 : Text[255]);
    VAR
      CSVJournal@1140000 : Record 5157807;
      AppendRec@5157802 : Boolean;
      No@1140001 : Integer;
    BEGIN
      No := 0;
      CSVJournal.RESET;
      IF Port.LogLastOnly THEN BEGIN
        CSVJournal.SETRANGE("Port Code",Port.Code);
        IF CSVJournal.FIND('+') THEN
          No := CSVJournal."No."
        ELSE
          AppendRec := TRUE;
      END ELSE
        AppendRec := TRUE;

      IF AppendRec THEN BEGIN
        CSVJournal.RESET;
        IF CSVJournal.FIND('+') THEN
          No := CSVJournal."No." + 1
        ELSE
          No := 1;
        CSVJournal.INIT;
        CSVJournal."No." := No;
        CSVJournal.INSERT;
      END;

      CSVJournal.GET(No);
      CSVJournal."Port Code" := Port.Code;
      CSVJournal."Table No." := Port."Table No.";
      CSVJournal."Table Caption" := Port."Table Caption";
      CSVJournal."File Name" := Filename;
      CSVJournal.Direction := Port.Direction;
      CSVJournal.Date := TODAY;
      CSVJournal.Time := TIME;
      CSVJournal."User ID" := USERID;
      CSVJournal."Records Skipped" := "Records Skipped";
      CSVJournal."Records Inserted" := "Records Inserted";
      CSVJournal."Records Modified" := "Records Modified";
      CSVJournal."Records Total" := "Records Skipped" + "Records Inserted" + "Records Modified";
      CSVJournal.MODIFY;
    END;

    PROCEDURE InsertPmtImportLine@1140017(ImportLine@1140000 : RecordRef);
    VAR
      ImportLine2@1140004 : RecordRef;
      Field1@1140005 : FieldRef;
      Field2@1140006 : FieldRef;
      Field3@5157802 : FieldRef;
      Field4@5157804 : FieldRef;
      Field5@5157805 : FieldRef;
      Field6@5157808 : FieldRef;
      Field7@5157807 : FieldRef;
      Stmt@5157809 : Code[20];
      xBank@1140008 : Code[40];
      xAccount@1140009 : Code[40];
      xCurrency@1140011 : Code[3];
      i@5157803 : Integer;
      LastField@1140003 : Integer;
      TempKey@1140010 : Integer;
      StmtLine@5157810 : Integer;
      RegNo@5157806 : Code[20];
    BEGIN
      CLEAR(PmtImportInterface);
      CLEAR(PmtImportLine);
      CLEAR(ImportLine2);

      i := PmtImportLine.FIELDNO("Bank Account-ID");
      Field1 := ImportLine.FIELD(i);
      xAccount := Field1.VALUE;
      IF STRLEN(xAccount) = 0 THEN
        ERROR(Text006,Counter);

      i := PmtImportLine.FIELDNO("Bank-ID");
      Field1 := ImportLine.FIELD(i);
      xBank := Field1.VALUE;

      i := PmtImportLine.FIELDNO("Currency-ID");
      Field1 := ImportLine.FIELD(i);
      xCurrency := Field1.VALUE;

      AccountsInserted += CheckAccountInterface(PmtImportInterface,xAccount,xBank,xCurrency);
      CompanyTemp.Name := PmtImportInterface."Import to Company";

      "Records Skipped" :=   "Records Skipped" ;
      IF STRLEN(CompanyTemp.Name) = 0 THEN BEGIN
        "Records Skipped" += 1;
        EXIT;
      END;

      IF CompanyTemp.INSERT THEN;
      RegNo := InsertJournal(CompanyTemp.Name,PmtImportInterface.Code);
      GLSetup.CHANGECOMPANY(CompanyTemp.Name);
      GLSetup.GET;
      IF xCurrency = GLSetup."LCY Code" THEN
        CLEAR(xCurrency);

      // Second instance for target company
      ImportLine2.OPEN(PmtEntryTableID,FALSE,CompanyTemp.Name);
      IF ImportLine2.FINDLAST THEN
        TempKey := ImportLine2.FIELD(1).VALUE;
      TempKey += 1;
      Field1 := ImportLine2.FIELD(1);
      Field1.VALUE := TempKey;
      LastField := ImportLine.FIELDCOUNT;
      FOR i := 2 TO LastField DO BEGIN
        Field1 := ImportLine.FIELDINDEX(i);
        Field2 := ImportLine2.FIELDINDEX(i);
        Field2.VALUE := Field1.VALUE;
      END;

      // Values from external tables, not to be found in importfile
      i := PmtImportLine.FIELDNO("Import Register No.");
      Field2 := ImportLine2.FIELD(i);
      Field2.VALUE := RegNo;

      i := PmtImportLine.FIELDNO("Import in Acc. No.");
      Field3 := ImportLine2.FIELD(i);
      Field3.VALUE := PmtImportInterface."Import to Account No.";

      i := PmtImportLine.FIELDNO("Pmt. Import Interface Code");
      Field4 := ImportLine2.FIELD(i);
      Field4.VALUE := PmtImportInterface.Code;

      i := PmtImportLine.FIELDNO("Import in Acc. Type");
      Field5 := ImportLine2.FIELD(i);
      Field5.VALUE := PmtImportInterface."Import to Account Type";

      i := PmtImportLine.FIELDNO("Statement No.");
      Field6 := ImportLine2.FIELD(i);
      Stmt := Field6.VALUE;

      i := PmtImportLine.FIELDNO("Statement Line No.");
      Field7 := ImportLine2.FIELD(i);
      StmtLine := Field7.VALUE;

      IF (Stmt <> '') AND (StmtLine = 0) THEN BEGIN
        StmtLineNo += 1;
        Field7.VALUE := StmtLineNo;
      END;

      ImportLine2.INSERT;
      ImportLine2.CLOSE;
      "Records Inserted" += 1;
    END;

    PROCEDURE CheckAccountInterface@5157804(VAR AccountInterface@5157802 : Record 5157810;ACode@5157806 : Code[40];BCode@5157803 : Code[40];VAR CCode@5157804 : Code[3]) Inserted : Integer;
    VAR
      NextCode@5157808 : Code[20];
    BEGIN
      Inserted := 0;
      WITH AccountInterface DO BEGIN
        SETRANGE("Interface Account No.",ACode);
        SETRANGE("Interface Bank-ID",BCode);
        SETRANGE("Interface Currency-ID",CCode);
        IF NOT FIND('-') THEN BEGIN
          RESET;
          NextCode := NoSeriesMgmt.GetNextNo(OPplusSetup."Pmt. Import Interface Nos.",WORKDATE,TRUE);
          INIT;
          Code := NextCode;
          "Interface Account No." := ACode;
          "Interface Bank-ID" := BCode;
          "Interface Currency-ID" := CCode;
          New := TRUE;
          INSERT;
          Inserted := 1;
        END;
      END;
      EXIT(Inserted);
    END;

    PROCEDURE FillField@5157810(VAR FieldVar@5157802 : FieldRef;TextPara@5157803 : Text[1024]);
    VAR
      Max@5157805 : Integer;
      FieldType@5157804 : Text[30];
      TestDate@5157808 : Date;
      TestInt@5157807 : Integer;
      TestDec@5157806 : Decimal;
      TestTime@5157809 : Time;
    BEGIN
      // "if FRef.Type = FRef.Type::Boolean ..." wonÔt work, so

      FieldType := FORMAT(FieldVar.TYPE);
      Max := FieldVar.LENGTH;
      CASE FieldType OF
        'Text':
          FieldVar.VALUE := COPYSTR(TextPara,1,Max);
        'Code':
          FieldVar.VALUE := COPYSTR(TextPara,1,Max);
        'Integer':
          IF EVALUATE(TestInt,TextPara) THEN
            FieldVar.VALUE := TestInt;
        'Option':
          IF EVALUATE(TestInt,TextPara) THEN
            FieldVar.VALUE := TestInt;
        'Decimal':
          IF EVALUATE(TestDec,TextPara) THEN
            FieldVar.VALUE := TestDec;
        'Date':
          IF EVALUATE(TestDate,TextPara) THEN
            FieldVar.VALUE := TestDate;
        'Time':
          IF EVALUATE(TestTime,TextPara) THEN
            FieldVar.VALUE := TestTime;
        'Boolean':
          IF LOWERCASE(TextPara) IN ['1','ja','yes','wahr','true'] THEN
            FieldVar.VALUE := TRUE;
        ELSE
          FieldVar.VALUE := COPYSTR(FORMAT(TextPara),1,Max);
      END;
    END;

    PROCEDURE GetOption@5157813(StrPara@5157802 : Text[250]) : Integer;
    VAR
      i@5157804 : Integer;
      k@5157803 : Integer;
    BEGIN
      k := STRPOS(StrPara,',');
      WHILE k > 0 DO BEGIN
        i += 1;
        StrPara := COPYSTR(StrPara,k+1);
        k := STRPOS(StrPara,',');
      END;
      EXIT(i);
    END;

    PROCEDURE InsertJournal@5157807(Comp@5157803 : Text[30];InterfaceCode@5157804 : Code[20]) : Code[20];
    VAR
      Register@5157802 : Record 5157808;
    BEGIN
      Register.RESET;
      Register.CHANGECOMPANY(Comp);
      Register.SETRANGE("In Progress",TRUE);
      Register.SETRANGE("Pmt. Import Interface",InterfaceCode);

      IF NOT Register.FIND('-') THEN BEGIN
        Register.INIT;
        Register."No." := NoSeriesMgmt.GetNextNo(OPplusSetup."Pmt. Import Journal Nos.",TODAY,TRUE);
        Register."No. Series" := OPplusSetup."Pmt. Import Journal Nos.";
        Register."Port Code" := COPYSTR(Port.Code,1,MAXSTRLEN(Register."Port Code"));
        Register.Filename := COPYSTR(MessageFilename,1,MAXSTRLEN(Register.Filename));
        Register."Import Date" := TODAY;
        Register.Time := TIME;
        Register."User ID" := USERID;
        Register."Pmt. Import Interface" := InterfaceCode;
        Register."In Progress" := TRUE;
        Register.INSERT;
      END;

      EXIT(Register."No.");
    END;

    PROCEDURE GetFileName@5157806(FileNamePara@5157803 : Text[1024];Code@5157802 : Code[20]) : Text[1024];
    BEGIN
      // External calls
      IF Code <> '' THEN BEGIN
        Port.GET(Code);
        IF Port.BankImport THEN
          OPplusSetup.GET;
      END;

      IF Port.BankImport THEN BEGIN
        IF OPplusSetup."Filename Pmt. Interface File" <> '' THEN
          EXIT(CommonDlgMgt.OpenFile(Text011,OPplusSetup."Filename Pmt. Interface File",4,Text017,0))
        ELSE
          EXIT(CommonDlgMgt.OpenFile(Text011,Port."File Name",4,Text017,0));
      END ELSE
        EXIT(CommonDlgMgt.OpenFile(Text020,FileNamePara,4,Text017,0));
    END;

    PROCEDURE SetGlobals@5157817(Filename@5157803 : Text[1024]) : Text[255];
    VAR
      TestStr@5157802 : Text[30];
    BEGIN
      CRLF[1] := 13; CRLF[2] := 10;
      COLON[1] := 39; // (')
      TAB[1] := 9;

      Separator := Port.Separator;
      IF DELCHR(Port.Separator) = '' THEN
        Separator := TAB;
      CASE Port.Delimiter OF
        Port.Delimiter::none: Delimiter := '';
        Port.Delimiter::single : Delimiter := COLON;
        Port.Delimiter::double : Delimiter := '"';
      END;

      TestStr := FORMAT(1000.5,0,'<Integer Thousand><Decimal>');
      ThousandSeparator := COPYSTR(TestStr,2,1);
      DecimalSeparator := COPYSTR(TestStr,6,1);
      IF Port.ThousandSep = '' THEN
        Port.ThousandSep := ThousandSeparator;
      IF Port.DecimalSep = '' THEN
        Port.DecimalSep := DecimalSeparator;

      EXIT(FinanceTools.ExtractFilename(Filename));
    END;

    PROCEDURE TestTable@5157811() : Text[50];
    BEGIN
      Objects.RESET;
      Objects.SETRANGE(Type,Objects.Type::Table);
      Objects.SETRANGE(ID,Port."Table No.");
      IF Objects.FIND('-') THEN BEGIN
        Objects.CALCFIELDS(Caption);
        EXIT(COPYSTR(Port."Table Caption",1,MAXSTRLEN(TableCaption)));
      END ELSE
        ERROR(Text024,Port."Table No.");
    END;

    PROCEDURE SetDebug@5157812(Filename@5157802 : Text[255]);
    VAR
      Text10000@5157803 : TextConst 'DEU=Debugfile "%1" konnte nicht erstellt werden.;ENU=Could not create debug file "%1".';
    BEGIN
      IF Filename <> '' THEN BEGIN
        dFile.TEXTMODE := TRUE;
        dFile.WRITEMODE := TRUE;
        IF NOT ISSERVICETIER THEN
          dFile.QUERYREPLACE := FALSE;
        IF dFile.CREATE(Filename) THEN
          DEBUG := TRUE AND GUIALLOWED
        ELSE
          MESSAGE(Text10000, Filename);
      END;
    END;

    PROCEDURE CheckPayment@5157808();
    BEGIN
      OPplusSetup.GET;
      OPplusSetup.TESTFIELD("Pmt. Import Journal Nos.");
      ImportJournal.RESET;
      IF ImportJournal.FINDLAST THEN
        ImportRegisterNo := ImportJournal."No."
      ELSE
        ImportRegisterNo := '-';

      Objects.SETRANGE(Type,Objects.Type::Table);
      Objects.SETRANGE(Name,PmtImportLine.TABLENAME);
      Objects.FIND('-');
      PmtEntryTableID := Objects.ID;
      Port.TESTFIELD("Table No.",Objects.ID);
      Port.TESTFIELD(BankImport,TRUE);

      PortLine.SETRANGE("Field No.",PmtImportLine.FIELDNO("Bank-ID"));
      IF NOT PortLine.FIND('-') THEN
        ERROR(Text004, PmtImportLine.FIELDCAPTION("Bank-ID"));
      PortLine.SETRANGE("Field No.",PmtImportLine.FIELDNO("Bank Account-ID"));
      IF NOT PortLine.FIND('-') THEN
        ERROR(Text004, PmtImportLine.FIELDCAPTION("Bank Account-ID"));
      PortLine.SETRANGE("Field No.");
    END;

    PROCEDURE CheckKeys@5157814();
    VAR
      LocalFieldRef@5157802 : FieldRef;
      LocalKeyRef@5157803 : KeyRef;
      i@5157804 : Integer;
      j@5157805 : Integer;
    BEGIN
      // Look for Primary Key
      i := myRec.KEYCOUNT;
      LocalKeyRef := myRec.KEYINDEX(1);
      FOR i := 1 TO LocalKeyRef.FIELDCOUNT DO BEGIN
        LocalFieldRef := myRec.FIELDINDEX(i);
        PortLine.SETRANGE("Field No.",LocalFieldRef.NUMBER);
        IF PortLine.FIND('-') THEN
          j += 1;
      END;

      IF j = LocalKeyRef.FIELDCOUNT THEN BEGIN
        // All fields in the key will be imported: do nothing
      END ELSE BEGIN
        IF LocalKeyRef.FIELDCOUNT = 1 THEN BEGIN
          PrimaryKeyField := LocalFieldRef.NUMBER;
          All.GET(Port."Table No.",LocalFieldRef.NUMBER);
          IF myRec.FIND('+') THEN BEGIN
            IF All.Type = All.Type::Integer THEN BEGIN
              PrimaryKeyInt := LocalFieldRef.VALUE;
              PrimaryKeyInt += 1;
            END ELSE IF All.Type = All.Type::Code THEN BEGIN
              PrimaryKeyCode := LocalFieldRef.VALUE;
              PrimaryKeyCode := INCSTR(PrimaryKeyCode);
            END;
          END ELSE BEGIN
            IF All.Type = All.Type::Integer THEN
              PrimaryKeyInt := 1
            ELSE IF All.Type = All.Type::Code THEN
              PrimaryKeyCode := '10000';
          END;
        END ELSE
          ERROR(Text007);
      END;
    END;

    PROCEDURE PrepareTables@5157815(PortCode@5157802 : Code[20];Append@5157803 : Boolean) : Integer;
    BEGIN
      Port.GET(PortCode);
      PortLine.RESET;
      PortLine.SETRANGE(Code,Port.Code);
      PortLine.SETCURRENTKEY(Code,"Table No.",Position);
      IF NOT Append THEN BEGIN
        IF PortLine.FIND('-') THEN BEGIN
          IF CONFIRM (Text005,FALSE,FALSE) THEN
            PortLine.DELETEALL
          ELSE
            EXIT(0);
        END;
      END;
      IF PortLine.FIND('+') THEN
        EXIT(PortLine.Position)
      ELSE
        EXIT(1);
    END;

    PROCEDURE LineProcedures@5157816(PortCode@5157802 : Code[20];ProcessOption@5157803 : 'Process,NoProcess,Trigger,NoTrigger,Deflate,Inflate');
    VAR
      Ok@5157804 : Boolean;
      LineNo@5157806 : Integer;
      Text10000@5157805 : TextConst 'DEU="Interner Fehler. Unbekannter Parameter bei Funktion LineProcedures: %1. ";ENU=Internal Error. Unknown parameter "%1" with function LineProcedures: %1.';
    BEGIN
      Port.GET(PortCode);
      PortLine.RESET;
      PortLine.SETRANGE(Code,Port.Code);
      IF NOT PortLine.FIND('-') THEN
        EXIT;

      Ok := TRUE;
      CASE ProcessOption OF
        ProcessOption::Process: PortLine.MODIFYALL("Processing Only",FALSE);
        ProcessOption::NoProcess: PortLine.MODIFYALL("Processing Only",TRUE);
        ProcessOption::Trigger: PortLine.MODIFYALL(SkipTrigger,FALSE);
        ProcessOption::NoTrigger: PortLine.MODIFYALL(SkipTrigger,TRUE);
        ProcessOption::Inflate:
          BEGIN
            PortLine.FIND('+');
            REPEAT
              PortLine.Position := PortLine.Position * 10;
              PortLine.MODIFY;
            UNTIL PortLine.NEXT(-1) = 0;
          END;
        ProcessOption::Deflate:
          BEGIN
            LineNo := 0;
            PortLine.FIND('-');
            REPEAT
              LineNo += 1;
              PortLine.Position := LineNo;
              PortLine.MODIFY;
            UNTIL PortLine.NEXT(1) = 0;
          END;
        ELSE
          Ok := FALSE;
      END;
      IF NOT Ok THEN
        ERROR(Text10000,FORMAT(ProcessOption));
      COMMIT;
    END;

    PROCEDURE PreviewProcedures@5157818(ProcNo@5157806 : Integer;TextPara@5157807 : Text[250]) : Boolean;
    VAR
      MigrationRecord@5157808 : Record 8614;
      MigrationData@5157804 : Record 8615;
      MigrationTableField@5157803 : Record 8616;
      MigrationForm@5157802 : Form 8626;
      i@5157805 : Integer;
      FormCaptions@5157811 : ARRAY [100] OF Text[100];
      FormCaption@5157809 : Text[100];
      Text10000@5157810 : TextConst 'DEU=" [gekÅrzt]";ENU=" [abbrv.]"';
    BEGIN
      IF ProcNo = 1 THEN BEGIN
        PreviewMax := 100;
        PreviewColumn := 0;
        i := 0;
        PortLine.FIND('-');
        REPEAT
          i += 1;
          IF i < PreviewMax + 1 THEN BEGIN
            IF (PortLine."Field No." > 0) AND NOT PortLine."Processing Only" THEN BEGIN
              IF PortLine.Formatstring = '' THEN BEGIN
                MigrationTableField.INIT;
                MigrationTableField.TableID := PortLine."Table No.";
                MigrationTableField.FieldID := PortLine."Field No.";
                MigrationTableField.Include := TRUE;
                MigrationTableField.Validate := FALSE;
                MigrationTableField.OPP_Preview := TRUE;
                MigrationTableField.INSERT;
              END;
            END;
          END;
        UNTIL PortLine.NEXT = 0;

        MigrationRecord.RESET;
        MigrationRecord.LOCKTABLE;
        IF MigrationRecord.FIND('+') THEN
          PreviewRecord := MigrationRecord."No."
        ELSE
          PreviewRecord := 0;
        PreviewStartRecord := PreviewRecord + 1;

      END ELSE IF ProcNo = 2 THEN BEGIN
        MigrationRecord.INIT;
        MigrationRecord.TableID := PortLine."Table No.";
        MigrationRecord."No." := PreviewRecord;
        MigrationRecord.INSERT;

      END ELSE IF ProcNo = 3 THEN BEGIN
        MigrationData.INIT;
        MigrationData.TableID := PortLine."Table No.";
        MigrationData."No." := PreviewRecord;
        MigrationData.FieldID := PortLine."Field No.";
        MigrationData.Value := TextPara;
        MigrationData.INSERT(FALSE);

      END ELSE IF ProcNo = 4 THEN BEGIN

        All.SETRANGE(TableNo,PortLine."Table No.");
        All.FIND('-');
        i := 0;
        PortLine.SETRANGE(Formatstring,'');
        REPEAT
          PortLine.SETRANGE("Field No.",All."No.");
          IF PortLine.FIND('-') THEN BEGIN
            IF NOT PortLine."Processing Only" THEN BEGIN
              i += 1;
              IF i < PreviewMax + 1 THEN
                FormCaptions[i] := All."Field Caption";
            END;
          END;
        UNTIL All.NEXT = 0;

        FormCaption := Port.TABLENAME;
        IF PortLine.COUNT > PreviewMax THEN
          FormCaption += Text10000;

        MigrationRecord.SETRANGE("No.",PreviewStartRecord,PreviewRecord);
        MigrationForm.SETTABLEVIEW(MigrationRecord);
        MigrationForm.Load(FormCaptions,FormCaption,Port."Table No.");
        COMMIT;
        MigrationForm.RUNMODAL;

        MigrationRecord.SETRANGE("No.",PreviewStartRecord,PreviewRecord);
        MigrationRecord.DELETEALL(TRUE);
        MigrationTableField.SETRANGE(OPP_Preview,TRUE);
        MigrationTableField.DELETEALL;
      END;
    END;

    PROCEDURE CustomProcedure@5157820(ID@5157802 : Integer;TextPara@5157803 : Text[1024]) : Text[1024];
    VAR
      n@5157804 : Integer;
      tDate@5157805 : Date;
      new@5157806 : Text[30];
    BEGIN
      // Demo Custom Procedure (future release)
      IF ID = 1 THEN BEGIN
        n := STRPOS(TextPara,' ');
        IF n > 0 THEN BEGIN
          new := COPYSTR(TextPara,1,n-1);
          CASE COPYSTR(TextPara,n+1,3) OF
            'Jan': new += '1';
            'Feb': new += '2';
            'Mrz': new += '3';
            'Apr': new += '4';
            'Mai': new += '5';
            'Jun': new += '6';
            'Jul': new += '7';
            'Aug': new += '8';
            'Sep': new += '9';
            'Okt': new += '10';
            'Nov': new += '11';
            'Dez': new += '12';
          END;
          new += '.11';
        END;
        IF NOT EVALUATE(tDate,new) THEN
          EXIT('')
        ELSE
          EXIT(new);
      END;
    END;

    PROCEDURE PreCheckFilter@5157821(VAR Line@5157802 : BigText) : Boolean;
    VAR
      TempText@5157803 : Text[250];
      BigLine@5157804 : BigText;
      BigLine2@5157805 : BigText;
      Pos@5157806 : Integer;
      HasDelimiter@5157807 : Boolean;
      PortLine_Temp@5157808 : Record 5157806;
      SkipLine@5157809 : Boolean;
      AllTest@5157810 : Record 2000000041;
    BEGIN
      SkipLine := FALSE;
      BigLine := Line;
      PortLine_Temp.RESET;
      PortLine_Temp.SETCURRENTKEY(Code,"Table No.",Position);
      PortLine_Temp.SETRANGE(Code,Port.Code);
      PortLine_Temp.FINDSET;
      REPEAT
        CLEAR(TempText);

        IF PortLine_Temp."Filter to ignore" <> '' THEN
          IF STRPOS(TempText,PortLine_Temp."Filter to ignore") > 0 THEN BEGIN
            SkipLine := TRUE;
          END;
        IF Port.FixCol THEN BEGIN
          IF PortLine_Temp.Colwidth > 0 THEN
            BigLine.GETSUBTEXT(TempText,PortLine_Temp.StartPos,PortLine_Temp.Colwidth);
        END ELSE BEGIN
          Pos := BigLine.TEXTPOS(Separator);
          IF Pos < 1 THEN BEGIN
            BigLine.GETSUBTEXT(TempText,1);
            IF Delimiter <> '' THEN
              TempText := DELCHR(TempText,'<>',Delimiter)
          END ELSE BEGIN
            BigLine.GETSUBTEXT(TempText,1,1);
            CLEAR(HasDelimiter);
            IF TempText = Delimiter THEN BEGIN
              HasDelimiter := TRUE;
              Pos := BigLine.TEXTPOS(Delimiter + Separator);
              IF Pos > 0 THEN BEGIN
                BigLine.GETSUBTEXT(TempText,2,Pos-2);
                BigLine.GETSUBTEXT(BigLine2,Pos+2);
              END;
            END ELSE BEGIN
              Pos := BigLine.TEXTPOS(Separator);
              IF Pos > 0 THEN BEGIN
                BigLine.GETSUBTEXT(TempText,1,Pos-1);
                BigLine.GETSUBTEXT(BigLine2,Pos+1);
              END;
            END;
          END;
          IF Port.Encoding = Port.Encoding::ANSI THEN BEGIN
            IF AllTest.GET(PortLine_Temp."Table No.",PortLine_Temp."Field No.") THEN;
            IF AllTest.Type IN [AllTest.Type::Code, AllTest.Type::Option, AllTest.Type::Text] THEN
              TempText := FinanceTools.Ansi2Ascii(TempText);
          END;

          TempText := DELCHR(TempText,'<>');
          IF PortLine_Temp."Filter to ignore" <> '' THEN
            IF STRPOS(TempText,PortLine_Temp."Filter to ignore") > 0 THEN BEGIN
              SkipLine := TRUE;
          END;

          CLEAR(BigLine);
          BigLine2.GETSUBTEXT(BigLine,1);
          CLEAR(BigLine2);
        END;

      UNTIL PortLine_Temp.NEXT = 0;
      IF SkipLine THEN
        EXIT(FALSE)
      ELSE
        EXIT(TRUE);
    END;

    PROCEDURE CheckFormula@1(Formula@1000 : Code[250]);
    VAR
      i@1001 : Integer;
      ParenthesesLevel@1002 : Integer;
      HasOperator@1003 : Boolean;
    BEGIN
      // gbedv HS 02.01.13 / Berechnung mit Formeln begin
      ParenthesesLevel := 0;
      FOR i := 1 TO STRLEN(Formula) DO BEGIN
        IF Formula[i] = '(' THEN
          ParenthesesLevel := ParenthesesLevel + 1
        ELSE
          IF Formula[i] = ')' THEN
            ParenthesesLevel := ParenthesesLevel - 1;
        IF ParenthesesLevel < 0 THEN
          ERROR(Text001,i);
        IF Formula[i] IN ['+','-','*','/','^'] THEN BEGIN
          IF HasOperator THEN
            ERROR(Text002,i)
          ELSE
            HasOperator := TRUE;
          IF i = STRLEN(Formula) THEN
            ERROR(Text003,i)
          ELSE
            IF Formula[i+1] = ')' THEN
              ERROR(Text003,i);
        END ELSE
          HasOperator := FALSE;
      END;
      IF ParenthesesLevel > 0 THEN
        ERROR(Text004)
      ELSE
        IF ParenthesesLevel < 0 THEN
          ERROR(Text005);
      // gbedv HS 02.01.13 / Berechnung mit Formeln end
    END;

    PROCEDURE Calculate@5157822(Expression@1000 : Text[250];Separator@1012 : Char) : Text[250];
    VAR
      Pos@1001 : Integer;
      strBuf@1002 : Text[250];
      stackNumber@1003 : ARRAY [256] OF Decimal;
      stackNumberCount@1004 : Integer;
      stackSign@1005 : ARRAY [256] OF Char;
      stackSignCount@1006 : Integer;
      decNumber1@1007 : Decimal;
      decNumber2@1008 : Decimal;
      Text001@1009 : TextConst 'ENU=Error: You cannot enter ''%1'' in decimal.';
      Text002@1010 : TextConst 'ENU=Error: The Calc is not support ''%1'' symbol.';
      flagBegin@1011 : Boolean;
      strFormula@5157802 : Text[250];
      Text003@5157803 : TextConst 'DEU=Der zu errechnende Wert wird zu gro·;ENU=The calculated Value will be too big';
    BEGIN
      // gbedv HS 02.01.13 / Berechnung mit Formeln begin
      Pos := 1;

      WHILE Pos <= STRLEN(Expression) DO BEGIN
        CASE Expression[Pos] OF

         '0'..'9':
           BEGIN
             strBuf := COPYSTR(Expression,Pos,1);
             WHILE (Expression[Pos + 1] IN ['0'..'9']) OR (Expression[Pos + 1] = Separator) DO BEGIN
               Pos += 1;
               strBuf := strBuf + COPYSTR(Expression,Pos,1);
             END;
             stackNumberCount += 1;
             IF NOT EVALUATE(stackNumber[stackNumberCount],strBuf) THEN
               EXIT(STRSUBSTNO(Text001,strBuf));
           END;

         '-','+','*','/','^':
          BEGIN
           IF (Expression[Pos] = '-') AND flagBegin THEN
            BEGIN
             stackNumberCount += 1;
             stackNumber[stackNumberCount] := -1;
             stackSignCount += 1;
             stackSign[stackSignCount] := '*';
            END
           ELSE
            BEGIN
             stackSignCount += 1;
             stackSign[stackSignCount] := Expression[Pos];
            END;
          END;

         ')':
          BEGIN
            IF stackSignCount > 0 THEN BEGIN
              decNumber1 := stackNumber[stackNumberCount];
              stackNumberCount -= 1;
              decNumber2 := stackNumber[stackNumberCount];
              CASE stackSign[stackSignCount] OF
                '-': decNumber2 -= decNumber1;
                '+': decNumber2 += decNumber1;
                '*': decNumber2 *= decNumber1;
                '/': decNumber2 /= decNumber1;
                '^': IF POWER(decNumber2,decNumber1) <= 999999999999999.0 THEN
                       decNumber2 := POWER(decNumber2,decNumber1)
                     ELSE
                       ERROR(Text003);
              END;
              stackSignCount -= 1;
              stackNumber[stackNumberCount] := decNumber2;
            END;
          END;

         ' ','(':
          WHILE Expression[Pos + 1] IN [' ','('] DO
             Pos += 1;
         ELSE
           EXIT(STRSUBSTNO(Text002,Expression[Pos]));
        END;
        flagBegin := Expression[Pos] = '(';
        Pos += 1;
      END;
      EXIT(FORMAT(stackNumber[stackNumberCount]));
      // gbedv HS 02.01.13 / Berechnung mit Formeln end
    END;

    PROCEDURE setValue@2(TempText@5157802 : Text[30];PortCode@5157805 : Code[20];Position@5157806 : Integer) : Decimal;
    VAR
      TempDec@5157803 : Decimal;
      PortLine_Temp@5157804 : Record 5157806;
    BEGIN
      // gbedv HS 02.01.13 / Berechnung mit Formeln begin
      IF TempText <> '' THEN BEGIN
        PortLine_Temp.GET(PortCode,Position);
        IF Port.ThousandSep <> ThousandSeparator THEN
          TempText := CONVERTSTR(TempText,Port.ThousandSep,'@');
        IF Port.DecimalSep <> DecimalSeparator THEN
          TempText := CONVERTSTR(TempText,Port.DecimalSep,DecimalSeparator);
        TempText := CONVERTSTR(TempText,'@',ThousandSeparator);
        EVALUATE(TempDec,TempText);
        IF PortLine_Temp.Amounts = PortLine_Temp.Amounts::Absolute THEN BEGIN
          IF TempDec < 0 THEN
            TempDec := TempDec * -1;
        END ELSE IF PortLine_Temp.Amounts = PortLine_Temp.Amounts::Invert THEN
          TempDec := TempDec * -1
        ELSE IF PortLine_Temp.Amounts = PortLine_Temp.Amounts::Default THEN BEGIN
          IF Port.Amounts = Port.Amounts::Absolute THEN BEGIN
            IF TempDec < 0 THEN
              TempDec := TempDec * -1;
          END ELSE IF Port.Amounts = Port.Amounts::Invert THEN
            TempDec := TempDec * -1;
        END;
        IF PortLine_Temp.Factor <> 0 THEN
          TempDec := TempDec * PortLine_Temp.Factor;
      END;

      EXIT(TempDec)
      // gbedv HS 02.01.13 / Berechnung mit Formeln end
    END;

    PROCEDURE MakeDate2@1000000000(Input@1000000000 : Text[30]) Result : Date;
    VAR
      DD@1000000003 : Integer;
      MM@1000000002 : Integer;
      YYYY@1000000001 : Integer;
    BEGIN
      //H0580 28.02.2014 ARI ++++++++++++++++++++++++++++++++
      EVALUATE(DD,COPYSTR(Input,7));
      EVALUATE(MM,COPYSTR(Input,5,2));
      EVALUATE(YYYY,COPYSTR(Input,1,4));
      Result := DMY2DATE(DD,MM,YYYY);
      //H0580 28.02.2014 ARI --------------------------------
    END;

    PROCEDURE CheckforValidLineBreaks@1000000001(FilePathV@1000000000 : Text[250]) : Text[250];
    VAR
      OriginalFileL@1000000009 : File;
      TemporaryFileL@1000000001 : File;
      InstreamL@1000000008 : InStream;
      Outstream@1000000002 : OutStream;
      ImportLineL@1000000006 : Text[1024];
      TemporaryFilePathL@1000000005 : Text[250];
      CharacterL@1000000004 : Char;
      LineFeedCharL2@1000000003 : Char;
    BEGIN
      //H1299 18.08.14 ARI ++++++++++++++++++++++++++

      OriginalFileL.OPEN(FilePathV);
      OriginalFileL.CREATEINSTREAM(InstreamL);

      LineFeedCharL2 := 10; // LF - ASCII code 10.
      ImportLineL := '';

      TemporaryFilePathL := INSSTR(FilePathV,'_2',STRPOS(FilePathV,'.csv'));

      TemporaryFileL.CREATE(TemporaryFilePathL);
      TemporaryFileL.CREATEOUTSTREAM(Outstream);

      WHILE NOT (InstreamL.EOS) DO BEGIN
        InstreamL.READ(CharacterL,1);
        IF CharacterL = 13 THEN BEGIN  //CR - ASCII code 13
          ImportLineL := ImportLineL + FORMAT(CharacterL) +FORMAT(LineFeedCharL2);
          Outstream.WRITETEXT(ImportLineL);
          ImportLineL := '';
        END ELSE BEGIN
          ImportLineL := ImportLineL + FORMAT(CharacterL);
        END;

      END;

      OriginalFileL.CLOSE();
      TemporaryFileL.CLOSE();

      EXIT(TemporaryFilePathL);

      //H1299 18.08.14 ARI --------------------------
    END;

    EVENT xmlDoc@5157832::ondataavailable@198();
    BEGIN
    END;

    EVENT xmlDoc@5157832::onreadystatechange@-609();
    BEGIN
    END;

    BEGIN
    {
      -----------------------------------------------------
      (c) gbedv, OPplus, All rights reserved

      No.  Date       changed
      -----------------------------------------------------
      EA   01.11.08   Extended Application
                      - Object created
      -----------------------------------------------------

      +--------------------------------------------+
      |                                            |
      |                  Home24                    |
      |       Internal Customizing by NAV-Team     |
      |                                            |
      +--------------------------------------------+

      Project No. Date     Shortcut  Description
      _____________________________________________

      H0580       28.02.14 ARI       Use Different Date Calculation when needed
      H0993       24.04.14 ARI       Insert new Line for Fees in Pmt. Import
      H0581       06.03.14 ARI       GUIALLOWED added to suppress Dialogs
      H1097       26.05.14 ARI       ChangeValue if Debit or Credit
      H1299       18.08.14 ARI       Concardis Import: Added new Function to check for valid Line Breaks
    }
    END.
  }
}

